<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=icon type=image/ico href=https://www.arjenwiersma.nl//favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.arjenwiersma.nl//favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.arjenwiersma.nl//favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=https://www.arjenwiersma.nl//android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=https://www.arjenwiersma.nl//apple-touch-icon.png><meta name=description content><meta property="og:image" content="https://www.arjenwiersma.nl/social.png"><title>Advent of Code 2023 day 8 | Arjen Wiersma
</title><link rel=canonical href=https://www.arjenwiersma.nl/posts/aoc-2023-day-8/><link rel=stylesheet href=/assets/combined.min.a6824bbee0d90d5af09fed9b70395ce7076b615e315037455d903314e96ef91b.css media=all></head><body class=auto><div class=content><header><div class=header><h1 class=header-title>Arjen Wiersma</h1><div class=flex><p class=small><a href=/>/home</a></p><p class=small><a href=/posts>/posts</a></p><p class=small><a href=/tags>/tags</a></p></div></div></header><main class=main><div class=breadcrumbs><a href=/>Home</a>
<span class=breadcrumbs-separator>> </span><a href=/posts/>Posts</a>
<span class=breadcrumbs-separator>> </span><a class=breadcrumbs-current href=/posts/aoc-2023-day-8/>Advent of Code 2023 day 8</a></div><div><div class=single-intro-container><h1 class=single-title>Advent of Code 2023 day 8</h1><p class=single-readtime><time datetime=2023-12-09T07:27:00+01:00>9 Dec 2023</time></p></div><div class=single-content><p>Somewhat suspicious of 2 easy days we end up at Day 8. A simple map to follow again, from one key follow the instructions until we hit <code>ZZZ</code>. Part 2 had us do it for several keys at once, with the goal to find the spot where they all converge. This can take <strong>forever</strong>, erhm, a long time.</p><p>So there has to be a math type solution to this problem. It turns out to be a Least Common Multiple problem. It is the smallest positive integer that is divisible by two or more numbers without leaving a remainder. To find the LCM of two or more numbers, you can use a method called prime factorization or a simpler approach involving multiples. We can also use the Greatest Common Divisor (GCD) to find the LCM.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>LCM(a, b) = (a * b) / GCD(a, b)
</span></span></code></pre></div><p>Example: Find the LCM of 12 and 18 using their GCD.</p><p>Step 1: Find the GCD of 12 and 18.</p><ul><li>You can use methods like prime factorization or the Euclidean algorithm to find the GCD.</li><li>GCD(12, 18) = 6</li></ul><p>Step 2: Use the formula to find the LCM.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>LCM(12, 18) = (12 * 18) / 6 = 216 / 6 = 36
</span></span></code></pre></div><p>So, the LCM of 12 and 18 is 36.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>import</span> (
</span></span><span style=display:flex><span>	<span style=font-style:italic>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=font-style:italic>&#34;strings&#34;</span>
</span></span><span style=display:flex><span>	<span style=font-style:italic>&#34;time&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=font-style:italic>&#34;arjenwiersma.nl/aoc/internal/aoc&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>func</span> LCM(numbers []<span>int</span>) <span>int</span> {
</span></span><span style=display:flex><span>	result := numbers[0]
</span></span><span style=display:flex><span>	<span style=font-weight:700>for</span> i := 1; i &lt; len(numbers); i++ {
</span></span><span style=display:flex><span>		result = (result * numbers[i]) / GCD(result, numbers[i])
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=font-weight:700>return</span> result
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>func</span> GCD(a, b <span>int</span>) <span>int</span> {
</span></span><span style=display:flex><span>	<span style=font-weight:700>if</span> b == 0 {
</span></span><span style=display:flex><span>		<span style=font-weight:700>return</span> a
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=font-weight:700>return</span> GCD(b, a%b)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>func</span> solve(s <span>string</span>, instr <span>string</span>, m <span style=font-weight:700>map</span>[<span>string</span>][]<span>string</span>, p2 <span>bool</span>) <span>int</span> {
</span></span><span style=display:flex><span>	steps := 0
</span></span><span style=display:flex><span>	<span style=font-weight:700>for</span> {
</span></span><span style=display:flex><span>		d := 0
</span></span><span style=display:flex><span>		<span style=font-weight:700>if</span> string(instr[steps%len(instr)]) == <span style=font-style:italic>&#34;R&#34;</span> {
</span></span><span style=display:flex><span>			d = 1
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=font-weight:700>if</span> !p2 &amp;&amp; s == <span style=font-style:italic>&#34;ZZZ&#34;</span> {
</span></span><span style=display:flex><span>			<span style=font-weight:700>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=font-weight:700>if</span> p2 &amp;&amp; s[2] == <span style=font-style:italic>&#39;Z&#39;</span> {
</span></span><span style=display:flex><span>			<span style=font-weight:700>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		s = m[s][d]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		steps += 1
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=font-weight:700>return</span> steps
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=font-weight:700>func</span> main() {
</span></span><span style=display:flex><span>	content := aoc.AsLines(<span style=font-style:italic>&#34;2023/Day08/input.txt&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	instr := content[0]
</span></span><span style=display:flex><span>	m := make(<span style=font-weight:700>map</span>[<span>string</span>][]<span>string</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=font-weight:700>for</span> _, v := <span style=font-weight:700>range</span> content[2:] {
</span></span><span style=display:flex><span>		n := strings.Split(v, <span style=font-style:italic>&#34; = &#34;</span>)
</span></span><span style=display:flex><span>		lr := strings.Split(n[1], <span style=font-style:italic>&#34;,&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		m[n[0]] = []<span>string</span>{strings.TrimSpace(lr[0][1:]), strings.TrimSpace(lr[1][:len(lr[1])-1])}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	startTime := time.Now()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	steps := solve(<span style=font-style:italic>&#34;AAA&#34;</span>, instr, m, <span style=font-weight:700>false</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	endTime := time.Now()
</span></span><span style=display:flex><span>	elapsed := endTime.Sub(startTime)
</span></span><span style=display:flex><span>	fmt.Printf(<span style=font-style:italic>&#34;Part 1: %d (%v)\n&#34;</span>, steps, elapsed)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	startTime = time.Now()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=font-weight:700>var</span> solves []<span>int</span>
</span></span><span style=display:flex><span>	<span style=font-weight:700>for</span> k := <span style=font-weight:700>range</span> m {
</span></span><span style=display:flex><span>		<span style=font-weight:700>if</span> k[2] == <span style=font-style:italic>&#39;A&#39;</span> {
</span></span><span style=display:flex><span>			solves = append(solves, solve(k, instr, m, <span style=font-weight:700>true</span>))
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=font-style:italic>// do stuff
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>	endTime = time.Now()
</span></span><span style=display:flex><span>	elapsed = endTime.Sub(startTime)
</span></span><span style=display:flex><span>	fmt.Printf(<span style=font-style:italic>&#34;Part 2: %d (%v)\n&#34;</span>, LCM(solves), elapsed)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><div class=single-pagination><hr><div class=flex><div class=single-pagination-prev><div class=single-pagination-container-prev><div class=single-pagination-text>←</div><div class=single-pagination-text><a href=/posts/aoc-2023-day-7/>Advent of Code 2023 day 7</a></div></div></div><div class=single-pagination-next><div class=single-pagination-container-next><div class=single-pagination-text><a href=/posts/aoc-2023-day-9/>Advent of Code 2023 day 9</a></div><div class=single-pagination-text>→</div></div></div></div><hr></div><div class=back-to-top><a href=#top>back to top</a></div></div></main></div><footer><p>Powered by
<a href=https://gohugo.io/>Hugo</a>
and
<a href=https://github.com/tomfran/typo>tomfran/typo</a></p></footer></body><script>function isAuto(){return document.body.classList.contains("auto")}function setTheme(){if(!isAuto())return;document.body.classList.remove("auto");let e="light";window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches&&(e="dark"),document.body.classList.add(e)}function invertBody(){document.body.classList.toggle("dark"),document.body.classList.toggle("light")}isAuto()&&window.matchMedia("(prefers-color-scheme: dark)").addListener(invertBody),setTheme()</script></html>