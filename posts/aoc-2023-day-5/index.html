<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=icon type=image/ico href=https://www.arjenwiersma.nl//favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.arjenwiersma.nl//favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.arjenwiersma.nl//favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=https://www.arjenwiersma.nl//android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=https://www.arjenwiersma.nl//apple-touch-icon.png><meta name=description content><meta property="og:image" content="https://www.arjenwiersma.nl/social.png"><title>Advent of Code 2023 day 5 | Arjen Wiersma
</title><link rel=canonical href=https://www.arjenwiersma.nl/posts/aoc-2023-day-5/><link rel=stylesheet href=/assets/combined.min.a6824bbee0d90d5af09fed9b70395ce7076b615e315037455d903314e96ef91b.css media=all></head><body class=auto><div class=content><header><div class=header><h1 class=header-title>Arjen Wiersma</h1><div class=flex><p class=small><a href=/>/home</a></p><p class=small><a href=/posts>/posts</a></p><p class=small><a href=/tags>/tags</a></p></div></div></header><main class=main><div class=breadcrumbs><a href=/>Home</a>
<span class=breadcrumbs-separator>> </span><a href=/posts/>Posts</a>
<span class=breadcrumbs-separator>> </span><a class=breadcrumbs-current href=/posts/aoc-2023-day-5/>Advent of Code 2023 day 5</a></div><div><div class=single-intro-container><h1 class=single-title>Advent of Code 2023 day 5</h1><p class=single-readtime><time datetime=2023-12-09T07:13:00+01:00>9 Dec 2023</time></p></div><div class=single-content><p>Today was an interesting problem. We are basically given a map to follow based on a number, possibly transforming the number at each step. With a single number this is quite simple, just apply the rules and step through each set of transformations. The problem becomes tricky when it turns out we have to deal with enormous ranges of numbers. On the subreddit some people reported their implementation to take hours and use 20GB of memory.</p><p>Luckily there is always a fast solution. In this case it was using ranges of numbers to go through the transformations, so just taking the first number and then creating a (new) range out of the transformation instead of each individual number.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>import</span> (
</span></span><span style=display:flex><span>	<span style=font-style:italic>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=font-style:italic>&#34;log&#34;</span>
</span></span><span style=display:flex><span>	<span style=font-style:italic>&#34;math&#34;</span>
</span></span><span style=display:flex><span>	<span style=font-style:italic>&#34;os&#34;</span>
</span></span><span style=display:flex><span>	<span style=font-style:italic>&#34;strconv&#34;</span>
</span></span><span style=display:flex><span>	<span style=font-style:italic>&#34;strings&#34;</span>
</span></span><span style=display:flex><span>	<span style=font-style:italic>&#34;time&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=font-style:italic>&#34;arjenwiersma.nl/aoc/internal/aoc&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>type</span> Range <span style=font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	d, s, r <span>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>func</span> (r *Range) transform(i <span>int</span>) <span>int</span> {
</span></span><span style=display:flex><span>	<span style=font-weight:700>if</span> i &gt;= r.s &amp;&amp; i &lt;= r.s+r.r-1 {
</span></span><span style=display:flex><span>		delta := i - r.s
</span></span><span style=display:flex><span>		<span style=font-weight:700>return</span> r.d + delta
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=font-weight:700>return</span> i
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>type</span> Segment <span style=font-weight:700>struct</span> {
</span></span><span style=display:flex><span>	from, to <span>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>func</span> main() {
</span></span><span style=display:flex><span>	content, _ := os.ReadFile(<span style=font-style:italic>&#34;2023/Day05/input.txt&#34;</span>)
</span></span><span style=display:flex><span>	segments := strings.Split(strings.TrimSpace(string(content)), <span style=font-style:italic>&#34;\n\n&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	seedStr := strings.Split(segments[0][6:], <span style=font-style:italic>&#34; &#34;</span>)
</span></span><span style=display:flex><span>	<span style=font-weight:700>var</span> seed []<span>int</span>
</span></span><span style=display:flex><span>	<span style=font-weight:700>for</span> _, x := <span style=font-weight:700>range</span> seedStr {
</span></span><span style=display:flex><span>		<span style=font-weight:700>if</span> strings.TrimSpace(x) == <span style=font-style:italic>&#34;&#34;</span> {
</span></span><span style=display:flex><span>			<span style=font-weight:700>continue</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		s, err := strconv.Atoi(strings.TrimSpace(x))
</span></span><span style=display:flex><span>		<span style=font-weight:700>if</span> err != <span style=font-weight:700>nil</span> {
</span></span><span style=display:flex><span>			log.Fatal(s, err)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		seed = append(seed, s)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=font-style:italic>// fmt.Println(&#34;Seeds: &#34;, seed)
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>
</span></span><span style=display:flex><span>	maps := make([][]Range, len(segments)-1)
</span></span><span style=display:flex><span>	<span style=font-weight:700>for</span> i, s := <span style=font-weight:700>range</span> segments[1:] {
</span></span><span style=display:flex><span>		l := strings.Split(s, <span style=font-style:italic>&#34;\n&#34;</span>)
</span></span><span style=display:flex><span>		maps[i] = make([]Range, len(l)-1)
</span></span><span style=display:flex><span>		<span style=font-weight:700>for</span> j, x := <span style=font-weight:700>range</span> l[1:] {
</span></span><span style=display:flex><span>			<span style=font-weight:700>var</span> m Range
</span></span><span style=display:flex><span>			fmt.Sscanf(x, <span style=font-style:italic>&#34;%d %d %d&#34;</span>, &amp;m.d, &amp;m.s, &amp;m.r)
</span></span><span style=display:flex><span>			maps[i][j] = m
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	startTime := time.Now()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	min := math.MaxInt
</span></span><span style=display:flex><span>	<span style=font-weight:700>for</span> _, s := <span style=font-weight:700>range</span> seed {
</span></span><span style=display:flex><span>		c := s
</span></span><span style=display:flex><span>	trans:
</span></span><span style=display:flex><span>		<span style=font-weight:700>for</span> _, m := <span style=font-weight:700>range</span> maps {
</span></span><span style=display:flex><span>			<span style=font-weight:700>for</span> _, t := <span style=font-weight:700>range</span> m {
</span></span><span style=display:flex><span>				source := c
</span></span><span style=display:flex><span>				c = t.transform(c)
</span></span><span style=display:flex><span>				<span style=font-weight:700>if</span> c != source {
</span></span><span style=display:flex><span>					<span style=font-weight:700>continue</span> trans
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=font-weight:700>if</span> c &lt; min {
</span></span><span style=display:flex><span>			min = c
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	endTime := time.Now()
</span></span><span style=display:flex><span>	elapsed := endTime.Sub(startTime)
</span></span><span style=display:flex><span>	fmt.Printf(<span style=font-style:italic>&#34;Part 1: %d (%v)\n&#34;</span>, min, elapsed) <span style=font-style:italic>// 662197086
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>
</span></span><span style=display:flex><span>	startTime = time.Now()
</span></span><span style=display:flex><span>	<span style=font-style:italic>// starting segments
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>	<span style=font-weight:700>var</span> S []Segment
</span></span><span style=display:flex><span>	<span style=font-weight:700>for</span> i := 0; i &lt; len(seed); i += 2 {
</span></span><span style=display:flex><span>		S = append(S, Segment{seed[i], seed[i] + seed[i+1]})
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=font-weight:700>for</span> _, m := <span style=font-weight:700>range</span> maps {
</span></span><span style=display:flex><span>		<span style=font-weight:700>var</span> A []Segment
</span></span><span style=display:flex><span>		<span style=font-weight:700>for</span> _, t := <span style=font-weight:700>range</span> m {
</span></span><span style=display:flex><span>			<span style=font-weight:700>var</span> nS []Segment
</span></span><span style=display:flex><span>			<span style=font-weight:700>for</span> _, s := <span style=font-weight:700>range</span> S {
</span></span><span style=display:flex><span>				nA, nnS := createSegments(s, t)
</span></span><span style=display:flex><span>				A = append(A, nA...)
</span></span><span style=display:flex><span>				nS = append(nS, nnS...)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			S = nS
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		S = append(S, A...)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	min = math.MaxInt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=font-weight:700>for</span> _, s := <span style=font-weight:700>range</span> S {
</span></span><span style=display:flex><span>		min = aoc.Min(s.from, min)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	endTime = time.Now()
</span></span><span style=display:flex><span>	elapsed = endTime.Sub(startTime)
</span></span><span style=display:flex><span>	fmt.Printf(<span style=font-style:italic>&#34;Part 2: %d (%v)\n&#34;</span>, min, elapsed) <span style=font-style:italic>// 52510809
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>func</span> createSegments(s Segment, t Range) (A []Segment, nS []Segment) {
</span></span><span style=display:flex><span>	before := Segment{s.from, aoc.Min(s.to, t.s)}
</span></span><span style=display:flex><span>	inter := Segment{aoc.Max(s.from, t.s), aoc.Min(t.s+t.r, s.to)}
</span></span><span style=display:flex><span>	after := Segment{aoc.Max(t.s+t.r, s.from), s.to}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=font-weight:700>if</span> before.to &gt; before.from {
</span></span><span style=display:flex><span>		nS = append(nS, before)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=font-weight:700>if</span> inter.to &gt; inter.from {
</span></span><span style=display:flex><span>		inter.from = inter.from - t.s + t.d
</span></span><span style=display:flex><span>		inter.to = inter.to - t.s + t.d
</span></span><span style=display:flex><span>		A = append(A, inter)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=font-weight:700>if</span> after.to &gt; after.from {
</span></span><span style=display:flex><span>		nS = append(nS, after)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=font-weight:700>return</span> A, nS
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><div class=single-pagination><hr><div class=flex><div class=single-pagination-prev><div class=single-pagination-container-prev><div class=single-pagination-text>←</div><div class=single-pagination-text><a href=/posts/aoc-2023-day-4/>Advent of Code 2023 Day 4</a></div></div></div><div class=single-pagination-next><div class=single-pagination-container-next><div class=single-pagination-text><a href=/posts/aoc-2023-day-6/>Advent of Code 2023 day 6</a></div><div class=single-pagination-text>→</div></div></div></div><hr></div><div class=back-to-top><a href=#top>back to top</a></div></div></main></div><footer><p>Powered by
<a href=https://gohugo.io/>Hugo</a>
and
<a href=https://github.com/tomfran/typo>tomfran/typo</a></p></footer></body><script>function isAuto(){return document.body.classList.contains("auto")}function setTheme(){if(!isAuto())return;document.body.classList.remove("auto");let e="light";window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches&&(e="dark"),document.body.classList.add(e)}function invertBody(){document.body.classList.toggle("dark"),document.body.classList.toggle("light")}isAuto()&&window.matchMedia("(prefers-color-scheme: dark)").addListener(invertBody),setTheme()</script></html>