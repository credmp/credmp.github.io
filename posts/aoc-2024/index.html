<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Advent of Code 2024 | Arjen Wiersma</title>
<meta name=keywords content><meta name=description content="It is December again and that means it is time for the Advent of Code. Due to my workload and family obligations I will probably not be able to get very far this year, but still I wanted to write a post about it.
This year I am using Java, together with my students. My goal is to write as modern as possible Java, which means using streams and new language constructs where possible."><meta name=author content="Arjen Wiersma"><meta property="og:title" content="Advent of Code 2024 | Arjen Wiersma"><meta property="og:type" content="website"><meta property="og:image" content="https://www.arjenwiersma.nl/social.png"><link rel=canonical href=https://www.arjenwiersma.nl/posts/aoc-2024/><link crossorigin=anonymous href=/assets/css/stylesheet.717ddaa7408a9c5e0c7adc285a222e56f696d8561e796beabc978873d989fa57.css integrity="sha256-cX3ap0CKnF4MetwoWiIuVvaW2FYeeWvqvJeIc9mJ+lc=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://www.arjenwiersma.nl/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.arjenwiersma.nl/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.arjenwiersma.nl/favicon-32x32.png><link rel=apple-touch-icon href=https://www.arjenwiersma.nl/apple-touch-icon.png><link rel=mask-icon href=https://www.arjenwiersma.nl/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.arjenwiersma.nl/posts/aoc-2024/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Advent of Code 2024"><meta property="og:description" content="It is December again and that means it is time for the Advent of Code. Due to my workload and family obligations I will probably not be able to get very far this year, but still I wanted to write a post about it.
This year I am using Java, together with my students. My goal is to write as modern as possible Java, which means using streams and new language constructs where possible."><meta property="og:type" content="article"><meta property="og:url" content="https://www.arjenwiersma.nl/posts/aoc-2024/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-15T00:00:00+01:00"><meta property="article:modified_time" content="2024-12-15T00:00:00+01:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Advent of Code 2024"><meta name=twitter:description content="It is December again and that means it is time for the Advent of Code. Due to my workload and family obligations I will probably not be able to get very far this year, but still I wanted to write a post about it.
This year I am using Java, together with my students. My goal is to write as modern as possible Java, which means using streams and new language constructs where possible."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.arjenwiersma.nl/posts/"},{"@type":"ListItem","position":2,"name":"Advent of Code 2024","item":"https://www.arjenwiersma.nl/posts/aoc-2024/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Advent of Code 2024","name":"Advent of Code 2024","description":"It is December again and that means it is time for the Advent of Code. Due to my workload and family obligations I will probably not be able to get very far this year, but still I wanted to write a post about it.\nThis year I am using Java, together with my students. My goal is to write as modern as possible Java, which means using streams and new language constructs where possible.\n","keywords":[],"articleBody":"It is December again and that means it is time for the Advent of Code. Due to my workload and family obligations I will probably not be able to get very far this year, but still I wanted to write a post about it.\nThis year I am using Java, together with my students. My goal is to write as modern as possible Java, which means using streams and new language constructs where possible.\nDay 1 In day 1 we are parsing 2 lists of numbers, with the lists printed vertically. This means each line has 2 numbers, one for list one and the other for list two. To parse these data structures I used a very nice stream where I map each line onto a String[] using split.\nTo be sure that the input is valid, the peek method allows you to check if the result is what you intended, and otherwise an exception will terminate everything. From here I map the String[] into a Pair record which holds the 2 numbers. Streaming over the resulting pairs the left and right lists can be extracted quite easily.\nI loved this approach, it is very straightforward and does not have a lot of control flow.\n@Override public List\u003cList\u003cInteger\u003e\u003e parseInput(List\u003cString\u003e input) { var pairs = input.stream() .map(s -\u003e s.split(\"\\\\s+\")) .peek(parts -\u003e { if (parts.length != 2) throw new IllegalArgumentException(\"Invalid input format\"); }) .map(parts -\u003e new Pair\u003c\u003e(Integer.parseInt(parts[0]), Integer.parseInt(parts[1]))) .collect(Collectors.toList()); var left = pairs.stream() .map(Pair::left) .collect(Collectors.toList()); var right = pairs.stream() .map(Pair::right) .collect(Collectors.toList()); return List.of(left, right); } Solving the problem with these lists was quite easy. In part 2 there was a need for a frequency table of a list. I also found a very nice solution to that problem using the groupingBy method from Collectors.\ninput.get(1).stream() .collect(Collectors.groupingBy(n -\u003e n, Collectors.counting())); Day 2 I really liked day 2, the first part was quite straightforward. You have to identify increment or decrement only lists and apply some conditions to them.\nPart 2 was much more interesting, here you have to account for fault tolerance. In the Python implementations that were posted the common solution is to concatenate 2 parts of the array and then rerun the validation logic.\nUsing streams we can something very similar. First we use an IntStream to iterate over every int[] (report). Then for every int in that report, we construct a new array by filtering out the index of the current item. After that it is a simple case of determining increment or decrement and applying the conditional logic.\nSuppose you have a list of [1,2,4,7], while iterating it will first hit index 0, the filter will prevent that entry from continuing. Next 1 through 3 will continue and as a result of toArray() a new array will be constructed with only those items.\nx == 0 | map ------. v ------- v [1, 2, 4, 7] [2,4,7] input.stream() // Loop over the list .filter(in -\u003e IntStream.range(0, in.length) // take a report // for every entry in that int[] .anyMatch(x -\u003e { // create a new list, excluding the one we are on now int[] c = IntStream.range(0, in.length) .filter(i -\u003e i != x) .map(i -\u003e in[i]) .toArray(); boolean allInc = IntStream.range(0, c.length - 1) .allMatch(i -\u003e c[i] \u003c= c[i + 1]); boolean allDec = IntStream.range(0, c.length - 1) .allMatch(i -\u003e c[i] \u003e= c[i + 1]); boolean good = IntStream.range(0, c.length - 1) .allMatch(i -\u003e Math.abs(c[i] - c[i + 1]) \u003e= 1 \u0026\u0026 Math.abs(c[i] - c[i + 1]) \u003c= 3); // matching the condition return (allInc || allDec) \u0026\u0026 good; }) ) .count(); My first solution was nothing like this, but after refining it I am very happy with how clean it came out.\nDay 3 This was the traditional easy puzzle after a more complicated one. Basically simple parsing for which I used regular expressions. Nothing special, on to day 4.\nDay 4 For day 4 I solved the first part with an over engineered path finding solution, which turned out to be quite the overkill, but extremely fun to program.\nI really like the pattern in use, below is some of the code of it. First you create a Deque that holds the work, then you load it up with the initial starting points. In the case of the puzzle these are the location of the X characters.\nFrom there you just loop over the work, taking a partial solution and seeing if any cells around it will lead to another partial solution, so from XM to XMA and on the next iteration to XMAS. The dx is a collection of Coord that indicate valid movements across the board.\nDeque\u003cPath\u003e work = new ArrayDeque\u003c\u003e(); // Load initial points for (int y = 0; y \u003c input.length; y++) { for (int x = 0; x \u003c input[y].length; x++) { if (input[y][x] == 'X') { work.add( new Path(List.of(new Coord(x,y)), \"X\", null) ); } } } // Process each outstanding point.. while (!work.isEmpty()) { var path = work.pop(); for (Coord d : dx) { if (path.dir() != null \u0026\u0026 path.dir != d) { continue; } var newCoord = lastStep.add(d); // Ensure this is a valid point on the grid if (newCoord.x() \u003e= 0 \u0026\u0026 newCoord.x() \u003c input[0].length \u0026\u0026 newCoord.y() \u003e= 0 \u0026\u0026 newCoord.y() \u003c input.length) { // ... create new paths and string based on location // Check if we have an end case, else add it to the work if (target.equals(xmas)) { matches.add(newPath); } else if (target.startsWith(xmas)) { work.add(newPath); } } } } A more straightforward approach, which was actually needed for part 2, is to just try to solve it in one step. First you iterate over both y and x coordinates looking for an X, just as above. When you find one, iterate over [-1, 0, 1] on both the x and y axis-es, using dy and dx for the direction. If both direction are 0, we continue as it would give the current position. The beauty of this approach is that you can move outward in steps, x + 3 * dx will give you a value 3 cells in the give direction. From there it is a simple matter of checking if we are in bounds and if the letters spell MAS.\nfor (int y = 0; y \u003c input.length; y++) { for (int x = 0; x \u003c input[y].length; x++) { if (input[y][x] != 'X') continue; for (int dy = -1; dy \u003c= 1; dy++) { for (int dx = -1; dx \u003c= 1; dx++) { if (dy == dx \u0026\u0026 dx == 0) continue; if (!(0 \u003c= y + 3 * dy \u0026\u0026 y + 3 * dy \u003c input.length \u0026\u0026 0 \u003c= x + 3 * dx \u0026\u0026 x + 3 * dx \u003c input[y].length)) continue; if (input[y+1*dy][x+1*dx] == 'M' \u0026\u0026 input[y+2*dy][x+2*dx] == 'A' \u0026\u0026 input[y+3*dy][x+3*dx] == 'S') { matches++; } } } } } For part 2 a similar approach can be used, however the order is not important. So I chose to create a List and then check against a target list with the containsAll method, it does not care about order.\nvar x1 = List.of(input[y-1][x-1], input[y][x], input[y+1][x+1]); var x2 = List.of(input[y-1][x+1], input[y][x], input[y+1][x-1]); if (x1.containsAll( target ) \u0026\u0026 x2.containsAll( target )){ matches++; } Another reminder to not over engineer at the start.\nDay 5 Another fun puzzle, when I initially read it my mind jumped to graphs. There is a 2 part input, the first part being a list of rules, numbers that are only valid when they are placed in front of other numbers.\nThe second part of the input is a list of report structures. The first quest was to validate the reports and find only the valid ones.\nMy first attempt, in part 1, was to take the rules for a number (a List) and see if there is an anyMatch of the sublist before it using order::contains. Basically if the pages is 75,97,47,61,53 and the rule 97|75 (97 should be before 75), the the loop will iterate over the pages, and check to see if [75] is in the list of rules for 97.\nboolean isValid(List\u003cInteger\u003e pages, Instructions input) { var valid = true; for (int i = 0; i \u003c pages.size(); i++) { var order = input.order().get(pages.get(i)); if (order != null) { var hasAny = pages.subList(0,i+1).stream().anyMatch(order::contains); if (hasAny) { valid = false; } } } return valid; } Part 2 had us fixing the broken pages. After some initial magic with arrays I figured out it is a basic sorting problem. In Java you can use Comparator implementations to create custom sorting rules, as long as it responds with -1,0,1 for to the left, the same, to the right. So the lambda Comparator takes a left hand side and right hand side value, retrieves the rules for the left hand side (if null it is equal 0) and checks to see if the right hand side is in the ruleset (-1). If all checks fail, the value should go to the right hand side.\nvar answer = 0L; for (var pages : input.pages()) { var valid = isValid(pages, input); var work = new ArrayList\u003c\u003e(pages); // pages is immutable if (!valid) { Collections.sort(work, (lhs, rhs) -\u003e { var order = input.order().get(lhs); if (order == null) return 0; if (order.contains(rhs)) return -1; return 1; }); answer += work.get(work.size()/2); } } A surprisingly easy solution to a messy problem when you want to implement it yourself.\nDay 6 Traditionally the Friday puzzles seem to be somewhat more challenging, this Friday is no exception. We are given a challenge similar to sliding puzzle games.\nInstead of sliding over ice we are to map the movements of a guard to ensure we can move safely through the area. For part 1 there was nothing too exciting, just move the guard over the floor and track the places visited. Depending on your loop you might accidentally avoid an edgecase that will show up in part 2.\nLets take a look at the loop:\nwhile (inBounds) { visited.add(start); var next = start.add(delta.get(sign)); if (!next.inBound(0, input[0].length, 0, input.length)) { inBounds = false; continue; } if (input[next.y()][next.x()] == '#') { sign = turns.get(sign); continue; } start = next; } While we are in bounds we keep moving, adding each step into the visited list. We then get the next position by retrieving the delta (a lookup table of coordinates such as -1,0, which indicate that the guard will move -1 on the x-axis and 0 on the y-axis). If we are out of bounds, flip the switch and break out of the while loop, if the next position is an obstacle, #, we set the sign to the 90 degree turned version (another lookup table) and rerun the loop. If, for some reason, you continue checking and validating at this point you might miss the edge-case that turning can result in facing another wall. When all the conditions are checked, simply reset the start variable to the next coordinates and move on.\nPart 2 becomes much more interesting; we are to find infinite loops by placing exactly 1 extra obstacle. Intuitively you will remark that the obstacle can only be placed on one of the cells that were visited in part 1. This already eliminates part of the board. From here you can loop over the list of coordinates, place an obstacle and let the guard run its route. When you visit a coordinate twice in the same direction you know you are in a loop.\nI looked for a ‚Äúsmart‚Äù solution, but the brute force is done in less then 2 seconds. So I will leave it at this, but somehow feel there might be more optimizations possible.\nDay 7 The end of week 1, and easier then the Friday puzzle. We are given a list of numbers per line that we need to either add or multiply to get to a target number. I chose to use some recursion to solve this problem. Each iteration of the recursion will reduce the array of numbers using one of the operations.\nIn the end the list of numbers will be reduced to either the target number, or something else. So the base case checks to see if it was successful.\nIf the base case is not hit, the first recursion is to add the numbers. A trick here is to use a LongStream to range over 1 to the end, mapping the numbers. If number 1 is mapped, we add the number at position 0 to reduce the array.\nThe second case applies the multiplication in the same way.\nThe third case (part 2) is to concatenate the numbers, this is easil done through number + \"\" + number in java, coercing the numbers into a String and then using Long.valueOf() to read the value again.\nboolean isValid(long target, long[] numbers, boolean third) { if (numbers.length == 1) return target == numbers[0]; if (isValid(target, LongStream.range(1, numbers.length) .map(i -\u003e { if (i == 1) return numbers[0] + numbers[1]; return numbers[(int)i]; }) .toArray(), third)) return true; if (isValid(target, LongStream.range(1, numbers.length) .map(i -\u003e { if (i == 1) return numbers[0] * numbers[1]; return numbers[(int)i]; }) .toArray(), third)) return true; if (third \u0026\u0026 isValid(target, LongStream.range(1, numbers.length) .map(i -\u003e { if (i == 1) return Long.valueOf(numbers[0] + \"\" + numbers[1]); return numbers[(int)i]; }) .toArray(), third)) return true; return false; } One last trick is to use the Stream feature to filter the list, mapping each object to a long value and summing.\n@Override public Long solver1(List\u003cCalibration\u003e input) { return input.stream().filter(i -\u003e isValid(i.target, i.numbers, false)).mapToLong(cal -\u003e cal.target).sum(); } Day 8 Day 8 has us back in history staring at antennas. The description was quite cryptic, but reading it carefully you learn that the necessary step is to find the difference between a pair of coordinates and then extrapolate the path inside the bounds of the grid.\nTo read the grid into a structure I used a simple nested loop, adding a new list to the map if it is absent, then adding the new coordinate for the antenna.\nfor (int r = 0; r \u003c gridH; r++) { for (int c = 0; c \u003c gridW; c++) { char ch = input.get(r).charAt(c); if (ch != '.') { antennas.computeIfAbsent(ch, k -\u003e new ArrayList\u003c\u003e()).add(new Coord(c, r)); } } } We then have to find the antinode for the point which, for the pair, is just a single difference step from the antenna. Interestingly we need to count the unique antinodes. Whenever you get such a requirement, always think about using a Set for storage.\nGetting the pairs is straightforward, and we have done it earlier in the series already. The first loop starts at 0 and ends the element before the end, size - 1. The inner loop starts at current pos + 1 and ends at the size of the list.\nfor (int p = 0; p \u003c coords.size() - 1; p++) { for (int n = p + 1; n \u003c coords.size(); n++) { Then just compute the difference and add the antinode when it is in bounds.\nvar antinode1 = cur.add(cur.diff(next)); var antinode2 = next.add(next.diff(cur)); In part 2 the path needs to be extrapolated until it goes out of bounds. This can easily be wrapped in its own method.\nvoid addAntinodesInDirection(Set\u003cCoord\u003e antinodes, Coord start, Coord diff) { var current = start; while (true) { var next = current.add(diff); if (!next.inBound(0, gridW, 0, gridH)) { break; } antinodes.add(next); current = next; } } A pretty straightforward problem to solve, on to tomorrow!\nDay 9 For me this was a hard day. We are given a list of numbers that we use to fragment files on a disk. The first part of the puzzle was quite straightforward, create a list that holds the file ids and spaces and just follow the rules.\nfor (int i = 0; i \u003c input.length(); i++) { for (int j = 0; j \u003c input.charAt(i)-'0'; j++) { if (i%2 == 0) { disk.add(id); } else { disk.add(null); } } if (i%2 == 0) { id++; } } From there just create 2 pointers, one on the left and one on the right. The left tracks the empty space and the right tracks the file ids that we want to put in the empty space. The important thing in Java is to make the implementation of the list a LinkedList. This allows for little-overhead reshuffling of the list.\nvar l = 0; var r = disk.size() - 1; while (l \u003c r) { if (disk.get(l) != null) { l++; continue; } if (disk.get(r) == null) { r--; continue; } disk.set(l, disk.get(r)); disk.set(r, null); l++; r--; } Part 2 became much harder, we are not to find space for the blocks of files instead of fragments. I first tried the same approach, but it took forever. I then saw the error of my ways and decided to use a lookup table for the empty spaces. This table maps the empty spaces of size N, in the below example 1 and 2, to a list of start/end coordinates.\n1 = [1,1] [2,2] 2 = [3,4] [6,7] The list of coordinates needs to remain sorted, so I used a PriorityQueue for it. Then it is just a matter of determining the size of the file under the r pointer by looping over it until we hit another id, and then looking up the most left candidate of the empty spaces.\n// Gets all candidates that will fit the file for (int i = bs; i \u003c 10; i++) { var earliest = free[i].peek(); if (earliest != null \u0026\u0026 earliest \u003c r) { candidates.add(new Candidate(i, earliest)); } } if (candidates.isEmpty()) { return null; } // Sort based on the index (most left first) candidates.sort((lhs, rhs) -\u003e { return lhs.idx() - rhs.idx(); }); var can = candidates.getFirst(); free[can.size()].remove(); The final solution runs in a matter of milliseconds, so I am quite happy with that.\nDay 10 Finally a depth first / breath first path seeker! We need to identify a trail that leads to a summit, or rather all trails that lead to the summit. Part 1 wants to know the score (how many summits can a path reach) and part 2 its rating (how many trails are there that reach a summit). This is pretty straightforward in the sense that you create a Queue and put the start of the trail in, then for each direction you construct a more complete path.\nAs always it is important to check for bounds and if the path is incremental (business rule). If the new path is actually at the summit, add it to the finished paths. If it is not, try to complete it.\nTrail solve(char[][] grid, Coord zero) { var q = new ArrayDeque\u003cList\u003cCoord\u003e\u003e(); q.add(List.of(zero)); List\u003cList\u003cCoord\u003e\u003e paths = new ArrayList\u003c\u003e(); while (!q.isEmpty()) { var current = q.removeFirst(); for (Coord d : zero.directNeighbors()) { var last = current.getLast(); var nc = last.add(d); if (!nc.inBound(0,grid[0].length, 0, grid.length)) continue; if (grid[nc.y()][nc.x()] != grid[last.y()][last.x()] + 1) continue; var newPath = new ArrayList\u003c\u003e(current); newPath.add(nc); if (grid[nc.y()][nc.x()] == '9') { paths.add(newPath); } else { q.addLast(newPath); } } } var score = paths.stream().map(l-\u003el.getLast()).collect(Collectors.toSet()).size(); var rating = paths.size(); return new Trail(score, rating); Day 11 - one to remember For the last couple of days the discussion forums have been full with memes about brute forcing the answer. Up to now you could really do so. I have one colleague who wrote a nice brute force for Day 6 that took several minutes, but it did work. Personally I am not a fan of the brute forcing approach, I like to make it more elegant when possible.\nToday is this years first Lanternfish type of problem, one where the problem space becomes so large that your computer is not able to brute force it due to memory constraints. It calls for a more elegant solution.\nPart 1 and part 2 are basically the same, the difference is the amount of iterations for the problem. In this case we have some rules in which rocks change and split up. We are tasked to find the amount of rocks after 25 and 75 iterations. The first is do-able with a brute force approach, the second is not.\nThe rules are straightforward, but the solution to the problem space might not be. The trick is to use something called memoization.\nIn computing, memoization or memoisation is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls to pure functions and returning the cached result when the same inputs occur again.\nSo, basically we store results of method calls. Lets first look at my solution. It is a recursive function that takes a number and the number of iterations to apply to it.\nif (iterations == 0) return 1; var cache = new Cache(number,iterations); if (memo.containsKey(cache)) { return memo.get(cache); } if (number == 0) { long l = ways(1, iterations - 1, memo); memo.put(cache, l); return l; } String s = \"\" + number; int l = s.length(); if (l % 2 == 0) { long c = ways(Long.parseLong(s.substring(0,l/2)), iterations-1, memo) + ways(Long.parseLong(s.substring(l/2,l)), iterations-1, memo); memo.put(cache, c); return c; } long c = ways(number * 2024, iterations-1, memo); memo.put(cache, c); return c; For this call the result is stored in a memo, a simple HashMap that stores the method arguments in a CacheKey and then stores the count, the result of the recursive call. What happens here is that there might be many different calls to this method, such as (9,23). In this case the number 9 has 23 iterations to go. By computing the result once and then storing the computed value we save the time of doing the same calculations many other times.\nThis was a really fun and relatively quick challenge, greatly enjoyed it!\nDay 12 - Garden Groups This day had me stumped for quite a time. The puzzle starts off with a simple question; group the garden (grid) into areas that are the same and count the fences required. A simple flood fill type of solution works very well here.\nWhenever a neighbor is not the same type (or we are the edge), a fence is required. If it is the same type, add it to the queue for further processing.\nfor (int r = 0; r \u003c input.length; r++) { for (int c = 0; c \u003c input[r].length; c++) { var start = new Coord(c, r); if (!seen.add(start)) { continue; } var queue = new ArrayDeque\u003cCoord\u003e(); queue.add(start); var cells = new HashSet\u003cCoord\u003e(); int perimeter = 0; char fenceType = input[r][c]; while (!queue.isEmpty()) { Coord cell = queue.poll(); cells.add(cell); for (Coord neighbor : Coord.directNeighbors()) { Coord next = cell.add(neighbor); if (!next.inBound(0, input[0].length, 0, input.length) || input[next.y()][next.x()] != fenceType) { perimeter++; } else if (seen.add(next)) { queue.add(next); } } } fences.add(new Fence(perimeter, cells)); } } The next part had me going for a little bit. Instead of the area or fences the elves need the sides counted. This turns out to be quite a thing until it becomes clear that counting corners also works.\nLets say the below map is our grid. When looking at the A in cell 0,2 it is possible to check if it is a corner by checking that the cell above it and the cell to the right are not the same. The same goes for the cell below and the cell to the right.\nA neat trick to find the sides to an area. The code turned out to be relatively easy:\nfor (var cell : fence.cells()) { char curr = input[cell.y()][cell.x()]; for (int ud : new int[]{-1, 1}) { for (int lr : new int[]{-1, 1}) { int ny = cell.y() + ud; int nx = cell.x() + lr; boolean outOfBoundsY = ny \u003c 0 || ny \u003e= input.length; boolean outOfBoundsX = nx \u003c 0 || nx \u003e= input[0].length; if ((outOfBoundsY || input[ny][cell.x()] != curr) \u0026\u0026 (outOfBoundsX || input[cell.y()][nx] != curr)) { corners++; } else if (!outOfBoundsY \u0026\u0026 !outOfBoundsX \u0026\u0026 input[ny][cell.x()] == curr \u0026\u0026 input[cell.y()][nx] == curr \u0026\u0026 input[ny][nx] != curr) { corners++; } } } On to Friday the 13th!\nDay 13 - Claw Contraption Today was quite something. We have claw machines that have 2 buttons. The buttons move the arm a set space on the x and y coordinates. Both buttons have a different value for the cost and we are tasked to find the cheapest path to a prize on some distant x and y location.\nMy initial solution was naive and used dynamic programming to solve it. It did not adhere to the rule every problem has a solution that completes in at most 15 seconds on ten-year-old hardware. So eventually I found a solution (thanks Hyperneutrino!) that uses math to solve this problem.\nBasically we are trying to find the amount of x and y movements both the A button (indicated by S) and the B button (indicated by T) have to make in order to get to the prize x and y values.\naxS + bxT = px ayS + byT = py We can make these equations the same by multiplying with by and bx. We do this so we can remove the B button from the equation and solve A.\naxbyS + bxbyT = pxby aybxS + bybxT = pybx Now bxbyT == bxbyT This can then be rewritten in a single equation, from which we can isolate A.\naxbyS - aybxS = pxby - pybx (axby-aybx)S = pxby - pybx Now we can divide by axby - aybx and get our solution for A. We have to ensure the input is never 0 to prevent division by zero. In the code we can check this by checking that ax * by == ay * bx never occurs.\nS = pxby - pybx ----------- axby - aybx As we now have the A button value, we can also solve the B button.\naxS + bxT = px bxT = px - axS T = px-axS ------ bx In code the solution looks very simple. Notice the ca%1==0 \u0026\u0026 cb%1==0 check to ensure we do not allow for fractional steps.\nprivate long solve(double ax, double ay, double bx, double by, long px, long py) { long answer = 0L; double ca = (px * by - py * bx) / (ax * by - ay * bx); double cb = (px - ax * ca) / bx; if (ca % 1 == 0 \u0026\u0026 cb % 1 == 0) { answer += (long) (ca*3) + cb; } return answer; } Day 14 - Restroom redoubt Today we are back at Easter Bunny HQ, looking for a restroom. We are given a collection of robots, their current position on a grid and their velocity. The question becomes, where are they after 100 iterations (seconds)? An interesting part of this question is that the robots wrap around the grid.\nThis mechanic allows for very easy calculation of the final coordinates, as (x + vx * 100) % width will give us the final position, instead of having to go through all the calculations.\nInterestingly, Java does not really like negative numbers in the modulo operator. For example, -102 % 11 yields -3 while it should yield 8 for it to be useful in our case. So, when the number is negative, just add the width to it.\nfor (var robot : robots) { int newX = (robot.start.x() + robot.vel.x() * 100) % width; if (newX \u003c 0) newX += width; int newY = (robot.start.y() + robot.vel.y() * 100) % height; if (newY \u003c 0) newY += height; positions.merge(new Coord(newX, newY), 1, Integer::sum); } Part 2 was a horrible puzzle. There was no clue what to do in order to get this:\nI finally solved it by looking at the field when all robots are on a unique position. I also have seen solution where the minimum safety value is found. The problem description was:\nDuring the bathroom break, someone notices that these robots seem awfully similar to ones built and used at the North Pole. If they‚Äôre the same type of robots, they should have a hard-coded Easter egg: very rarely, most of the robots should arrange themselves into a picture of a Christmas tree.\nWhat is the fewest number of seconds that must elapse for the robots to display the Easter egg?\nMaybe if it had said ‚Äúvery rarely, but when all the robots arrange themselves‚Äù, but then again, how are you supposed to know that it means non-overlapping.\nLove the Christmas tree though.\nDay 15 - Warehouse Woes Yay, the Lanternfish have made an appearance! Sadly this puzzle had me quite stumped for a while. I had to rewrite my solution 2 times in order to get it right.\nFirst, let me explain. We are still not finding the historian (whom I think is just Eric in a costume). Instead we are on a side-quest helping our fishy friends with robots in their warehouses. The first puzzle is straightforward; move the player around, moving objects that you run into.\nWhen we have that sorted we are sent to a second warehouse. This time the boxes that we move are twice as large, but the robot is still the same size. This means we get into situations as the following example:\n###### # # # [] # # @ # ###### Here the player can move up, but we are only hitting one side of the box. We have to take into account that we need to move the other part along as well. Even more complicated, we can get into the following situation.\n###### #[] # #[][]# # [] # # @ # ###### In this situation we can not move, even though the 2nd box on the middle layer might think we can, as it has a white-space above it.\nI worked on arrays for a while, but eventually went for a more ‚ÄúJava‚Äù solution and create the factory as objects. Using the objects it is possible to attack the problem more in a ‚Äúgame engine‚Äù type of way, by making each object react to the interaction.\nMy code is horrible not-optimized, I apologize for that right away, but it gets the job done :D\nFirstly, I split the process out into two segments, first to see if we can move, then to actually move. Side note: I should really use a lookup table for the coordinate to find the objects instead of looping over it.\nThe objects are simple POJOs, all extending the aptly named Thing.\nclass Player extends Thing { public Player(Coord start, Coord end) { super(start, end); } } class Wall extends Thing { public Wall(Coord start, Coord end) { super(start, end); this.canMove = false; } } class Box extends Thing { public Box(Coord start, Coord end) { super(start, end); } } Thing has all the logic, with canMove() and move basically doing the same thing, except for move actually moving the objects into a new coordinate. Only if we have a space as neighbor, or if all of the neighbors can move, only then do we move the current object.\nboolean move(List\u003cThing\u003e factory, Coord direction) { if (!canMove) return false; Coord nsp = start.add(direction); Coord nep = end.add(direction); Set\u003cThing\u003e hits = new HashSet\u003c\u003e(); for (var t : factory) { if (t == this) continue; if (t.collidesWith(nsp)) hits.add(t); if (t.collidesWith(nep)) hits.add(t); } if (hits.size() == 0) { // space, so we can move ourself this.start = this.start.add(direction); this.end = this.end.add(direction); return true; } if (hits.stream().allMatch(t -\u003e t.move(factory, direction))) { this.start = this.start.add(direction); this.end = this.end.add(direction); return true; } return false; } Collision is checked against both the left and right hand side of the object. Meaning that we can easily handle boxes of size 2.\nboolean collidesWith(Coord c) { if ((start.x() == c.x() \u0026\u0026 start.y() == c.y()) || (end.x() == c.x() \u0026\u0026 end.y() == c.y())) { return true; } return false; } Much more work then I thought it would be, but a nice solution anyways.\nMore to come [This article will be update with more days]\n","wordCount":"5343","inLanguage":"en","datePublished":"2024-12-15T00:00:00+01:00","dateModified":"2024-12-15T00:00:00+01:00","author":[{"@type":"Person","name":"Arjen Wiersma"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.arjenwiersma.nl/posts/aoc-2024/"},"publisher":{"@type":"Organization","name":"Arjen Wiersma","logo":{"@type":"ImageObject","url":"https://www.arjenwiersma.nl/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.arjenwiersma.nl/ accesskey=h title="Arjen Wiersma (Alt + H)">Arjen Wiersma</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://www.arjenwiersma.nl/categories/writing/ title="üîß Things I built"><span><i class='fa fa-heart'></i>üîß Things I built</span></a></li><li><a href=https://www.arjenwiersma.nl/categories/writing/ title="üöÄ Long form writings"><span><i class='fa fa-heart'></i>üöÄ Long form writings</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.arjenwiersma.nl/>Home</a>&nbsp;¬ª&nbsp;<a href=https://www.arjenwiersma.nl/posts/>Posts</a></div><h1 class=post-title>Advent of Code 2024</h1><div class=post-meta>December 15, 2024 - 26 min Arjen Wiersma</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#day-1 aria-label="Day 1">Day 1</a></li><li><a href=#day-2 aria-label="Day 2">Day 2</a></li><li><a href=#day-3 aria-label="Day 3">Day 3</a></li><li><a href=#day-4 aria-label="Day 4">Day 4</a></li><li><a href=#day-5 aria-label="Day 5">Day 5</a></li><li><a href=#day-6 aria-label="Day 6">Day 6</a></li><li><a href=#day-7 aria-label="Day 7">Day 7</a></li><li><a href=#day-8 aria-label="Day 8">Day 8</a></li><li><a href=#day-9 aria-label="Day 9">Day 9</a></li><li><a href=#day-10 aria-label="Day 10">Day 10</a></li><li><a href=#day-11-one-to-remember aria-label="Day 11 - one to remember">Day 11 - one to remember</a></li><li><a href=#day-12-garden-groups aria-label="Day 12 - Garden Groups">Day 12 - Garden Groups</a></li><li><a href=#day-13-claw-contraption aria-label="Day 13 - Claw Contraption">Day 13 - Claw Contraption</a></li><li><a href=#day-14-restroom-redoubt aria-label="Day 14 - Restroom redoubt">Day 14 - Restroom redoubt</a></li><li><a href=#day-15-warehouse-woes aria-label="Day 15 - Warehouse Woes">Day 15 - Warehouse Woes</a></li><li><a href=#more-to-come aria-label="More to come">More to come</a></li></ul></div></details></div><div class=post-content><p>It is December again and that means it is time for the <a href=https://adventofcode.com/>Advent of Code</a>. Due to my workload and family obligations I will probably not be able to get very far this year, but still I wanted to write a post about it.</p><p>This year I am using Java, together with my students. My goal is to write as modern as possible Java, which means using streams and new language constructs where possible.</p><h2 id=day-1>Day 1<a hidden class=anchor aria-hidden=true href=#day-1>#</a></h2><p>In day 1 we are parsing 2 lists of numbers, with the lists printed vertically. This means each line has 2 numbers, one for list one and the other for list two. To parse these data structures I used a very nice stream where I <code>map</code> each line onto a <code>String[]</code> using <code>split</code>.</p><p>To be sure that the input is valid, the <code>peek</code> method allows you to check if the result is what you intended, and otherwise an exception will terminate everything. From here I <code>map</code> the <code>String[]</code> into a <code>Pair</code> record which holds the 2 numbers. Streaming over the resulting <code>pairs</code> the left and right lists can be extracted quite easily.</p><p>I loved this approach, it is very straightforward and does not have a lot of control flow.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#89b4fa;font-weight:700>@Override</span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>public</span> List<span style=color:#89dceb;font-weight:700>&lt;</span>List<span style=color:#89dceb;font-weight:700>&lt;</span>Integer<span style=color:#89dceb;font-weight:700>&gt;&gt;</span> <span style=color:#89b4fa>parseInput</span>(List<span style=color:#89dceb;font-weight:700>&lt;</span>String<span style=color:#89dceb;font-weight:700>&gt;</span> input) {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> pairs <span style=color:#89dceb;font-weight:700>=</span> input.<span style=color:#89b4fa>stream</span>()
</span></span><span style=display:flex><span>        .<span style=color:#89b4fa>map</span>(s <span style=color:#89dceb;font-weight:700>-&gt;</span> s.<span style=color:#89b4fa>split</span>(<span style=color:#a6e3a1>&#34;\\s+&#34;</span>))
</span></span><span style=display:flex><span>        .<span style=color:#89b4fa>peek</span>(parts <span style=color:#89dceb;font-weight:700>-&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#cba6f7>if</span> (parts.<span style=color:#89b4fa>length</span> <span style=color:#89dceb;font-weight:700>!=</span> 2)
</span></span><span style=display:flex><span>                    <span style=color:#cba6f7>throw</span> <span style=color:#cba6f7>new</span> IllegalArgumentException(<span style=color:#a6e3a1>&#34;Invalid input format&#34;</span>);
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>        .<span style=color:#89b4fa>map</span>(parts <span style=color:#89dceb;font-weight:700>-&gt;</span> <span style=color:#cba6f7>new</span> Pair<span style=color:#89dceb;font-weight:700>&lt;&gt;</span>(Integer.<span style=color:#89b4fa>parseInt</span>(parts<span style=color:#89dceb;font-weight:700>[</span>0<span style=color:#89dceb;font-weight:700>]</span>), Integer.<span style=color:#89b4fa>parseInt</span>(parts<span style=color:#89dceb;font-weight:700>[</span>1<span style=color:#89dceb;font-weight:700>]</span>)))
</span></span><span style=display:flex><span>        .<span style=color:#89b4fa>collect</span>(Collectors.<span style=color:#89b4fa>toList</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> left <span style=color:#89dceb;font-weight:700>=</span> pairs.<span style=color:#89b4fa>stream</span>()
</span></span><span style=display:flex><span>        .<span style=color:#89b4fa>map</span>(Pair::left)
</span></span><span style=display:flex><span>        .<span style=color:#89b4fa>collect</span>(Collectors.<span style=color:#89b4fa>toList</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> right <span style=color:#89dceb;font-weight:700>=</span> pairs.<span style=color:#89b4fa>stream</span>()
</span></span><span style=display:flex><span>        .<span style=color:#89b4fa>map</span>(Pair::right)
</span></span><span style=display:flex><span>        .<span style=color:#89b4fa>collect</span>(Collectors.<span style=color:#89b4fa>toList</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> List.<span style=color:#89b4fa>of</span>(left, right);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Solving the problem with these lists was quite easy. In part 2 there was a need for a frequency table of a list. I also found a very nice solution to that problem using the <code>groupingBy</code> method from <code>Collectors</code>.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>input.<span style=color:#89b4fa>get</span>(1).<span style=color:#89b4fa>stream</span>()
</span></span><span style=display:flex><span>    .<span style=color:#89b4fa>collect</span>(Collectors.<span style=color:#89b4fa>groupingBy</span>(n <span style=color:#89dceb;font-weight:700>-&gt;</span> n, Collectors.<span style=color:#89b4fa>counting</span>()));
</span></span></code></pre></div><h2 id=day-2>Day 2<a hidden class=anchor aria-hidden=true href=#day-2>#</a></h2><p>I really liked day 2, the first part was quite straightforward. You have to identify increment or decrement only lists and apply some conditions to them.</p><p>Part 2 was much more interesting, here you have to account for fault tolerance. In the Python implementations that were posted the common solution is to concatenate 2 parts of the array and then rerun the validation logic.</p><p>Using streams we can something very similar. First we use an <code>IntStream</code> to iterate over every <code>int[]</code> (report). Then for every <code>int</code> in that report, we construct a new array by <code>filtering</code> out the index of the current item. After that it is a simple case of determining increment or decrement and applying the conditional logic.</p><blockquote><p>Suppose you have a list of <code>[1,2,4,7]</code>, while iterating it will first hit index <code>0</code>, the <code>filter</code> will prevent that entry from continuing. Next <code>1</code> through <code>3</code> will continue and as a result of <code>toArray()</code> a new array will be constructed with only those items.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>x == 0
</span></span><span style=display:flex><span>     |    map ------.
</span></span><span style=display:flex><span>     v  -------     v
</span></span><span style=display:flex><span>    [1, 2, 4, 7]    [2,4,7]
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>input.<span style=color:#89b4fa>stream</span>()
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Loop over the list</span>
</span></span><span style=display:flex><span>    .<span style=color:#89b4fa>filter</span>(in <span style=color:#89dceb;font-weight:700>-&gt;</span> IntStream.<span style=color:#89b4fa>range</span>(0, in.<span style=color:#89b4fa>length</span>) <span style=color:#6c7086;font-style:italic>// take a report</span>
</span></span><span style=display:flex><span>            <span style=color:#6c7086;font-style:italic>// for every entry in that int[]</span>
</span></span><span style=display:flex><span>            .<span style=color:#89b4fa>anyMatch</span>(x <span style=color:#89dceb;font-weight:700>-&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#6c7086;font-style:italic>// create a new list, excluding the one we are on now</span>
</span></span><span style=display:flex><span>                    <span style=color:#f38ba8>int</span><span style=color:#89dceb;font-weight:700>[]</span> c <span style=color:#89dceb;font-weight:700>=</span> IntStream.<span style=color:#89b4fa>range</span>(0, in.<span style=color:#89b4fa>length</span>)
</span></span><span style=display:flex><span>                        .<span style=color:#89b4fa>filter</span>(i <span style=color:#89dceb;font-weight:700>-&gt;</span> i <span style=color:#89dceb;font-weight:700>!=</span> x)
</span></span><span style=display:flex><span>                        .<span style=color:#89b4fa>map</span>(i <span style=color:#89dceb;font-weight:700>-&gt;</span> in<span style=color:#89dceb;font-weight:700>[</span>i<span style=color:#89dceb;font-weight:700>]</span>)
</span></span><span style=display:flex><span>                        .<span style=color:#89b4fa>toArray</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#f38ba8>boolean</span> allInc <span style=color:#89dceb;font-weight:700>=</span> IntStream.<span style=color:#89b4fa>range</span>(0, c.<span style=color:#89b4fa>length</span> <span style=color:#89dceb;font-weight:700>-</span> 1)
</span></span><span style=display:flex><span>                        .<span style=color:#89b4fa>allMatch</span>(i <span style=color:#89dceb;font-weight:700>-&gt;</span> c<span style=color:#89dceb;font-weight:700>[</span>i<span style=color:#89dceb;font-weight:700>]</span> <span style=color:#89dceb;font-weight:700>&lt;=</span> c<span style=color:#89dceb;font-weight:700>[</span>i <span style=color:#89dceb;font-weight:700>+</span> 1<span style=color:#89dceb;font-weight:700>]</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#f38ba8>boolean</span> allDec <span style=color:#89dceb;font-weight:700>=</span> IntStream.<span style=color:#89b4fa>range</span>(0, c.<span style=color:#89b4fa>length</span> <span style=color:#89dceb;font-weight:700>-</span> 1)
</span></span><span style=display:flex><span>                        .<span style=color:#89b4fa>allMatch</span>(i <span style=color:#89dceb;font-weight:700>-&gt;</span> c<span style=color:#89dceb;font-weight:700>[</span>i<span style=color:#89dceb;font-weight:700>]</span> <span style=color:#89dceb;font-weight:700>&gt;=</span> c<span style=color:#89dceb;font-weight:700>[</span>i <span style=color:#89dceb;font-weight:700>+</span> 1<span style=color:#89dceb;font-weight:700>]</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#f38ba8>boolean</span> good <span style=color:#89dceb;font-weight:700>=</span> IntStream.<span style=color:#89b4fa>range</span>(0, c.<span style=color:#89b4fa>length</span> <span style=color:#89dceb;font-weight:700>-</span> 1)
</span></span><span style=display:flex><span>                        .<span style=color:#89b4fa>allMatch</span>(i <span style=color:#89dceb;font-weight:700>-&gt;</span> Math.<span style=color:#89b4fa>abs</span>(c<span style=color:#89dceb;font-weight:700>[</span>i<span style=color:#89dceb;font-weight:700>]</span> <span style=color:#89dceb;font-weight:700>-</span> c<span style=color:#89dceb;font-weight:700>[</span>i <span style=color:#89dceb;font-weight:700>+</span> 1<span style=color:#89dceb;font-weight:700>]</span>) <span style=color:#89dceb;font-weight:700>&gt;=</span> 1 <span style=color:#89dceb;font-weight:700>&amp;&amp;</span>
</span></span><span style=display:flex><span>                                  Math.<span style=color:#89b4fa>abs</span>(c<span style=color:#89dceb;font-weight:700>[</span>i<span style=color:#89dceb;font-weight:700>]</span> <span style=color:#89dceb;font-weight:700>-</span> c<span style=color:#89dceb;font-weight:700>[</span>i <span style=color:#89dceb;font-weight:700>+</span> 1<span style=color:#89dceb;font-weight:700>]</span>) <span style=color:#89dceb;font-weight:700>&lt;=</span> 3);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#6c7086;font-style:italic>// matching the condition</span>
</span></span><span style=display:flex><span>                    <span style=color:#cba6f7>return</span> (allInc <span style=color:#89dceb;font-weight:700>||</span> allDec) <span style=color:#89dceb;font-weight:700>&amp;&amp;</span> good;
</span></span><span style=display:flex><span>                })
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>    .<span style=color:#89b4fa>count</span>();
</span></span></code></pre></div><p>My first solution was nothing like this, but after refining it I am very happy with how clean it came out.</p><h2 id=day-3>Day 3<a hidden class=anchor aria-hidden=true href=#day-3>#</a></h2><p>This was the traditional easy puzzle after a more complicated one. Basically simple parsing for which I used regular expressions. Nothing special, on to day 4.</p><h2 id=day-4>Day 4<a hidden class=anchor aria-hidden=true href=#day-4>#</a></h2><p>For day 4 I solved the first part with an over engineered path finding solution, which turned out to be quite the overkill, but extremely fun to program.</p><p>I really like the pattern in use, below is some of the code of it. First you create a <code>Deque</code> that holds the work, then you load it up with the initial starting points. In the case of the puzzle these are the location of the <code>X</code> characters.</p><p>From there you just loop over the <code>work</code>, taking a partial solution and seeing if any cells around it will lead to another partial solution, so from <code>XM</code> to <code>XMA</code> and on the next iteration to <code>XMAS</code>. The <code>dx</code> is a collection of <code>Coord</code> that indicate valid movements across the board.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Deque<span style=color:#89dceb;font-weight:700>&lt;</span>Path<span style=color:#89dceb;font-weight:700>&gt;</span> work <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>new</span> ArrayDeque<span style=color:#89dceb;font-weight:700>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Load initial points</span>
</span></span><span style=display:flex><span><span style=color:#cba6f7>for</span> (<span style=color:#f38ba8>int</span> y <span style=color:#89dceb;font-weight:700>=</span> 0; y <span style=color:#89dceb;font-weight:700>&lt;</span> input.<span style=color:#89b4fa>length</span>; y<span style=color:#89dceb;font-weight:700>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>for</span> (<span style=color:#f38ba8>int</span> x <span style=color:#89dceb;font-weight:700>=</span> 0; x <span style=color:#89dceb;font-weight:700>&lt;</span> input<span style=color:#89dceb;font-weight:700>[</span>y<span style=color:#89dceb;font-weight:700>]</span>.<span style=color:#89b4fa>length</span>; x<span style=color:#89dceb;font-weight:700>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> (input<span style=color:#89dceb;font-weight:700>[</span>y<span style=color:#89dceb;font-weight:700>][</span>x<span style=color:#89dceb;font-weight:700>]</span> <span style=color:#89dceb;font-weight:700>==</span> <span style=color:#a6e3a1>&#39;X&#39;</span>) {
</span></span><span style=display:flex><span>            work.<span style=color:#89b4fa>add</span>( <span style=color:#cba6f7>new</span> Path(List.<span style=color:#89b4fa>of</span>(<span style=color:#cba6f7>new</span> Coord(x,y)), <span style=color:#a6e3a1>&#34;X&#34;</span>, <span style=color:#fab387>null</span>) );
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Process each outstanding point..</span>
</span></span><span style=display:flex><span><span style=color:#cba6f7>while</span> (<span style=color:#89dceb;font-weight:700>!</span>work.<span style=color:#89b4fa>isEmpty</span>()) {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> path <span style=color:#89dceb;font-weight:700>=</span> work.<span style=color:#89b4fa>pop</span>();
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>for</span> (Coord d : dx) {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> (path.<span style=color:#89b4fa>dir</span>() <span style=color:#89dceb;font-weight:700>!=</span> <span style=color:#fab387>null</span> <span style=color:#89dceb;font-weight:700>&amp;&amp;</span> path.<span style=color:#89b4fa>dir</span> <span style=color:#89dceb;font-weight:700>!=</span> d) {
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>var</span> newCoord <span style=color:#89dceb;font-weight:700>=</span> lastStep.<span style=color:#89b4fa>add</span>(d);
</span></span><span style=display:flex><span>        <span style=color:#6c7086;font-style:italic>// Ensure this is a valid point on the grid</span>
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> (newCoord.<span style=color:#89b4fa>x</span>() <span style=color:#89dceb;font-weight:700>&gt;=</span> 0 <span style=color:#89dceb;font-weight:700>&amp;&amp;</span> newCoord.<span style=color:#89b4fa>x</span>() <span style=color:#89dceb;font-weight:700>&lt;</span> input<span style=color:#89dceb;font-weight:700>[</span>0<span style=color:#89dceb;font-weight:700>]</span>.<span style=color:#89b4fa>length</span> <span style=color:#89dceb;font-weight:700>&amp;&amp;</span>
</span></span><span style=display:flex><span>            newCoord.<span style=color:#89b4fa>y</span>() <span style=color:#89dceb;font-weight:700>&gt;=</span> 0 <span style=color:#89dceb;font-weight:700>&amp;&amp;</span> newCoord.<span style=color:#89b4fa>y</span>() <span style=color:#89dceb;font-weight:700>&lt;</span> input.<span style=color:#89b4fa>length</span>) {
</span></span><span style=display:flex><span>            <span style=color:#6c7086;font-style:italic>// ... create new paths and string based on location</span>
</span></span><span style=display:flex><span>            <span style=color:#6c7086;font-style:italic>// Check if we have an end case, else add it to the work</span>
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>if</span> (target.<span style=color:#89b4fa>equals</span>(xmas)) {
</span></span><span style=display:flex><span>                matches.<span style=color:#89b4fa>add</span>(newPath);
</span></span><span style=display:flex><span>            } <span style=color:#cba6f7>else</span> <span style=color:#cba6f7>if</span> (target.<span style=color:#89b4fa>startsWith</span>(xmas)) {
</span></span><span style=display:flex><span>                work.<span style=color:#89b4fa>add</span>(newPath);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A more straightforward approach, which was actually needed for part 2, is to just try to solve it in one step. First you iterate over both <code>y</code> and <code>x</code> coordinates looking for an <code>X</code>, just as above. When you find one, iterate over <code>[-1, 0, 1]</code> on both the <code>x</code> and <code>y</code> axis-es, using <code>dy</code> and <code>dx</code> for the <strong>direction</strong>. If both <code>direction</code> are <code>0</code>, we continue as it would give the current position. The beauty of this approach is that you can move outward in steps, <code>x + 3 * dx</code> will give you a value 3 cells in the give <code>direction</code>. From there it is a simple matter of checking if we are in bounds and if the letters spell <strong>MAS</strong>.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#cba6f7>for</span> (<span style=color:#f38ba8>int</span> y <span style=color:#89dceb;font-weight:700>=</span> 0; y <span style=color:#89dceb;font-weight:700>&lt;</span> input.<span style=color:#89b4fa>length</span>; y<span style=color:#89dceb;font-weight:700>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>for</span> (<span style=color:#f38ba8>int</span> x <span style=color:#89dceb;font-weight:700>=</span> 0; x <span style=color:#89dceb;font-weight:700>&lt;</span> input<span style=color:#89dceb;font-weight:700>[</span>y<span style=color:#89dceb;font-weight:700>]</span>.<span style=color:#89b4fa>length</span>; x<span style=color:#89dceb;font-weight:700>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> (input<span style=color:#89dceb;font-weight:700>[</span>y<span style=color:#89dceb;font-weight:700>][</span>x<span style=color:#89dceb;font-weight:700>]</span> <span style=color:#89dceb;font-weight:700>!=</span> <span style=color:#a6e3a1>&#39;X&#39;</span>) <span style=color:#cba6f7>continue</span>;
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>for</span> (<span style=color:#f38ba8>int</span> dy <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#89dceb;font-weight:700>-</span>1; dy <span style=color:#89dceb;font-weight:700>&lt;=</span> 1; dy<span style=color:#89dceb;font-weight:700>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>for</span> (<span style=color:#f38ba8>int</span> dx <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#89dceb;font-weight:700>-</span>1; dx <span style=color:#89dceb;font-weight:700>&lt;=</span> 1; dx<span style=color:#89dceb;font-weight:700>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#cba6f7>if</span> (dy <span style=color:#89dceb;font-weight:700>==</span> dx <span style=color:#89dceb;font-weight:700>&amp;&amp;</span> dx <span style=color:#89dceb;font-weight:700>==</span> 0) <span style=color:#cba6f7>continue</span>;
</span></span><span style=display:flex><span>                <span style=color:#cba6f7>if</span> (<span style=color:#89dceb;font-weight:700>!</span>(0 <span style=color:#89dceb;font-weight:700>&lt;=</span> y <span style=color:#89dceb;font-weight:700>+</span> 3 <span style=color:#89dceb;font-weight:700>*</span> dy <span style=color:#89dceb;font-weight:700>&amp;&amp;</span> y <span style=color:#89dceb;font-weight:700>+</span> 3 <span style=color:#89dceb;font-weight:700>*</span> dy <span style=color:#89dceb;font-weight:700>&lt;</span> input.<span style=color:#89b4fa>length</span> <span style=color:#89dceb;font-weight:700>&amp;&amp;</span>
</span></span><span style=display:flex><span>                      0 <span style=color:#89dceb;font-weight:700>&lt;=</span> x <span style=color:#89dceb;font-weight:700>+</span> 3 <span style=color:#89dceb;font-weight:700>*</span> dx <span style=color:#89dceb;font-weight:700>&amp;&amp;</span> x <span style=color:#89dceb;font-weight:700>+</span> 3 <span style=color:#89dceb;font-weight:700>*</span> dx <span style=color:#89dceb;font-weight:700>&lt;</span> input<span style=color:#89dceb;font-weight:700>[</span>y<span style=color:#89dceb;font-weight:700>]</span>.<span style=color:#89b4fa>length</span>)) <span style=color:#cba6f7>continue</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#cba6f7>if</span> (input<span style=color:#89dceb;font-weight:700>[</span>y<span style=color:#89dceb;font-weight:700>+</span>1<span style=color:#89dceb;font-weight:700>*</span>dy<span style=color:#89dceb;font-weight:700>][</span>x<span style=color:#89dceb;font-weight:700>+</span>1<span style=color:#89dceb;font-weight:700>*</span>dx<span style=color:#89dceb;font-weight:700>]</span> <span style=color:#89dceb;font-weight:700>==</span> <span style=color:#a6e3a1>&#39;M&#39;</span> <span style=color:#89dceb;font-weight:700>&amp;&amp;</span>
</span></span><span style=display:flex><span>                    input<span style=color:#89dceb;font-weight:700>[</span>y<span style=color:#89dceb;font-weight:700>+</span>2<span style=color:#89dceb;font-weight:700>*</span>dy<span style=color:#89dceb;font-weight:700>][</span>x<span style=color:#89dceb;font-weight:700>+</span>2<span style=color:#89dceb;font-weight:700>*</span>dx<span style=color:#89dceb;font-weight:700>]</span> <span style=color:#89dceb;font-weight:700>==</span> <span style=color:#a6e3a1>&#39;A&#39;</span> <span style=color:#89dceb;font-weight:700>&amp;&amp;</span>
</span></span><span style=display:flex><span>                    input<span style=color:#89dceb;font-weight:700>[</span>y<span style=color:#89dceb;font-weight:700>+</span>3<span style=color:#89dceb;font-weight:700>*</span>dy<span style=color:#89dceb;font-weight:700>][</span>x<span style=color:#89dceb;font-weight:700>+</span>3<span style=color:#89dceb;font-weight:700>*</span>dx<span style=color:#89dceb;font-weight:700>]</span> <span style=color:#89dceb;font-weight:700>==</span> <span style=color:#a6e3a1>&#39;S&#39;</span>) {
</span></span><span style=display:flex><span>                    matches<span style=color:#89dceb;font-weight:700>++</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For part 2 a similar approach can be used, however the order is not important. So I chose to create a <code>List</code> and then check against a target list with the <code>containsAll</code> method, it does not care about order.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f38ba8>var</span> x1 <span style=color:#89dceb;font-weight:700>=</span> List.<span style=color:#89b4fa>of</span>(input<span style=color:#89dceb;font-weight:700>[</span>y<span style=color:#89dceb;font-weight:700>-</span>1<span style=color:#89dceb;font-weight:700>][</span>x<span style=color:#89dceb;font-weight:700>-</span>1<span style=color:#89dceb;font-weight:700>]</span>, input<span style=color:#89dceb;font-weight:700>[</span>y<span style=color:#89dceb;font-weight:700>][</span>x<span style=color:#89dceb;font-weight:700>]</span>, input<span style=color:#89dceb;font-weight:700>[</span>y<span style=color:#89dceb;font-weight:700>+</span>1<span style=color:#89dceb;font-weight:700>][</span>x<span style=color:#89dceb;font-weight:700>+</span>1<span style=color:#89dceb;font-weight:700>]</span>);
</span></span><span style=display:flex><span><span style=color:#f38ba8>var</span> x2 <span style=color:#89dceb;font-weight:700>=</span> List.<span style=color:#89b4fa>of</span>(input<span style=color:#89dceb;font-weight:700>[</span>y<span style=color:#89dceb;font-weight:700>-</span>1<span style=color:#89dceb;font-weight:700>][</span>x<span style=color:#89dceb;font-weight:700>+</span>1<span style=color:#89dceb;font-weight:700>]</span>, input<span style=color:#89dceb;font-weight:700>[</span>y<span style=color:#89dceb;font-weight:700>][</span>x<span style=color:#89dceb;font-weight:700>]</span>, input<span style=color:#89dceb;font-weight:700>[</span>y<span style=color:#89dceb;font-weight:700>+</span>1<span style=color:#89dceb;font-weight:700>][</span>x<span style=color:#89dceb;font-weight:700>-</span>1<span style=color:#89dceb;font-weight:700>]</span>);
</span></span><span style=display:flex><span><span style=color:#cba6f7>if</span> (x1.<span style=color:#89b4fa>containsAll</span>( target ) <span style=color:#89dceb;font-weight:700>&amp;&amp;</span> x2.<span style=color:#89b4fa>containsAll</span>( target )){
</span></span><span style=display:flex><span>    matches<span style=color:#89dceb;font-weight:700>++</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Another reminder to not over engineer at the start.</p><h2 id=day-5>Day 5<a hidden class=anchor aria-hidden=true href=#day-5>#</a></h2><p>Another fun puzzle, when I initially read it my mind jumped to graphs. There is a 2 part input, the first part being a list of rules, numbers that are only valid when they are placed in front of other numbers.</p><p>The second part of the input is a list of <code>report</code> structures. The first quest was to validate the reports and find only the valid ones.</p><p>My first attempt, in part 1, was to take the rules for a number (a <code>List&lt;Integer></code>) and see if there is an <code>anyMatch</code> of the sublist before it using <code>order::contains</code>. Basically if the pages is <code>75,97,47,61,53</code> and the rule <code>97|75</code> (97 should be before 75), the the loop will iterate over the pages, and check to see if <code>[75]</code> is in the list of rules for <code>97</code>.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f38ba8>boolean</span> <span style=color:#89b4fa>isValid</span>(List<span style=color:#89dceb;font-weight:700>&lt;</span>Integer<span style=color:#89dceb;font-weight:700>&gt;</span> pages, Instructions input) {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> valid <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#fab387>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>for</span> (<span style=color:#f38ba8>int</span> i <span style=color:#89dceb;font-weight:700>=</span> 0; i <span style=color:#89dceb;font-weight:700>&lt;</span> pages.<span style=color:#89b4fa>size</span>(); i<span style=color:#89dceb;font-weight:700>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>var</span> order <span style=color:#89dceb;font-weight:700>=</span> input.<span style=color:#89b4fa>order</span>().<span style=color:#89b4fa>get</span>(pages.<span style=color:#89b4fa>get</span>(i));
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> (order <span style=color:#89dceb;font-weight:700>!=</span> <span style=color:#fab387>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#f38ba8>var</span> hasAny <span style=color:#89dceb;font-weight:700>=</span> pages.<span style=color:#89b4fa>subList</span>(0,i<span style=color:#89dceb;font-weight:700>+</span>1).<span style=color:#89b4fa>stream</span>().<span style=color:#89b4fa>anyMatch</span>(order::contains);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>if</span> (hasAny) {
</span></span><span style=display:flex><span>                valid <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#fab387>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> valid;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Part 2 had us fixing the broken pages. After some initial magic with arrays I figured out it is a basic sorting problem. In Java you can use <code>Comparator</code> implementations to create custom sorting rules, as long as it responds with <code>-1,0,1</code> for to the left, the same, to the right. So the lambda <code>Comparator</code> takes a left hand side and right hand side value, retrieves the rules for the left hand side (if <code>null</code> it is equal <code>0</code>) and checks to see if the right hand side is in the ruleset (<code>-1</code>). If all checks fail, the value should go to the right hand side.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f38ba8>var</span> answer <span style=color:#89dceb;font-weight:700>=</span> 0L;
</span></span><span style=display:flex><span><span style=color:#cba6f7>for</span> (<span style=color:#f38ba8>var</span> pages : input.<span style=color:#89b4fa>pages</span>()) {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> valid <span style=color:#89dceb;font-weight:700>=</span> isValid(pages, input);
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> work <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>new</span> ArrayList<span style=color:#89dceb;font-weight:700>&lt;&gt;</span>(pages); <span style=color:#6c7086;font-style:italic>// pages is immutable</span>
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> (<span style=color:#89dceb;font-weight:700>!</span>valid) {
</span></span><span style=display:flex><span>        Collections.<span style=color:#89b4fa>sort</span>(work, (lhs, rhs) <span style=color:#89dceb;font-weight:700>-&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#f38ba8>var</span> order <span style=color:#89dceb;font-weight:700>=</span> input.<span style=color:#89b4fa>order</span>().<span style=color:#89b4fa>get</span>(lhs);
</span></span><span style=display:flex><span>                <span style=color:#cba6f7>if</span> (order <span style=color:#89dceb;font-weight:700>==</span> <span style=color:#fab387>null</span>) <span style=color:#cba6f7>return</span> 0;
</span></span><span style=display:flex><span>                <span style=color:#cba6f7>if</span> (order.<span style=color:#89b4fa>contains</span>(rhs)) <span style=color:#cba6f7>return</span> <span style=color:#89dceb;font-weight:700>-</span>1;
</span></span><span style=display:flex><span>                <span style=color:#cba6f7>return</span> 1;
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>        answer <span style=color:#89dceb;font-weight:700>+=</span> work.<span style=color:#89b4fa>get</span>(work.<span style=color:#89b4fa>size</span>()<span style=color:#89dceb;font-weight:700>/</span>2);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A surprisingly easy solution to a messy problem when you want to implement it yourself.</p><h2 id=day-6>Day 6<a hidden class=anchor aria-hidden=true href=#day-6>#</a></h2><p>Traditionally the Friday puzzles seem to be somewhat more challenging, this Friday is no exception. We are given a challenge similar to sliding puzzle games.</p><p><video autoplay loop muted><source src=/ox-hugo/sliding.mp4></video></p><p>Instead of sliding over ice we are to map the movements of a guard to ensure we can move safely through the area. For part 1 there was nothing too exciting, just move the guard over the floor and track the places visited. Depending on your loop you might accidentally avoid an edgecase that will show up in part 2.</p><p>Lets take a look at the loop:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#cba6f7>while</span> (inBounds) {
</span></span><span style=display:flex><span>    visited.<span style=color:#89b4fa>add</span>(start);
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> next <span style=color:#89dceb;font-weight:700>=</span> start.<span style=color:#89b4fa>add</span>(delta.<span style=color:#89b4fa>get</span>(sign));
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> (<span style=color:#89dceb;font-weight:700>!</span>next.<span style=color:#89b4fa>inBound</span>(0, input<span style=color:#89dceb;font-weight:700>[</span>0<span style=color:#89dceb;font-weight:700>]</span>.<span style=color:#89b4fa>length</span>, 0, input.<span style=color:#89b4fa>length</span>)) {
</span></span><span style=display:flex><span>        inBounds <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#fab387>false</span>;
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> (input<span style=color:#89dceb;font-weight:700>[</span>next.<span style=color:#89b4fa>y</span>()<span style=color:#89dceb;font-weight:700>][</span>next.<span style=color:#89b4fa>x</span>()<span style=color:#89dceb;font-weight:700>]</span> <span style=color:#89dceb;font-weight:700>==</span> <span style=color:#a6e3a1>&#39;#&#39;</span>) {
</span></span><span style=display:flex><span>        sign <span style=color:#89dceb;font-weight:700>=</span> turns.<span style=color:#89b4fa>get</span>(sign);
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    start <span style=color:#89dceb;font-weight:700>=</span> next;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>While we are <strong><strong>in bounds</strong></strong> we keep moving, adding each step into the <code>visited</code> list. We then get the next position by retrieving the delta (a lookup table of coordinates such as <code>-1,0</code>, which indicate that the guard will move <code>-1</code> on the x-axis and <code>0</code> on the y-axis). If we are out of bounds, flip the switch and break out of the <code>while</code> loop, if the <code>next</code> position is an obstacle, <code>#</code>, we set the <code>sign</code> to the 90 degree turned version (another lookup table) and rerun the loop. If, for some reason, you continue checking and validating at this point you might miss the edge-case that turning can result in facing another wall. When all the conditions are checked, simply reset the <code>start</code> variable to the next coordinates and move on.</p><p>Part 2 becomes much more interesting; we are to find infinite loops by placing exactly 1 extra obstacle. Intuitively you will remark that the obstacle can only be placed on one of the cells that were visited in part 1. This already eliminates part of the board. From here you can loop over the list of coordinates, place an obstacle and let the guard run its route. When you visit a coordinate twice in <strong><strong>the same direction</strong></strong> you know you are in a loop.</p><p>I looked for a &ldquo;smart&rdquo; solution, but the brute force is done in less then 2 seconds. So I will leave it at this, but somehow feel there might be more optimizations possible.</p><h2 id=day-7>Day 7<a hidden class=anchor aria-hidden=true href=#day-7>#</a></h2><p>The end of week 1, and easier then the Friday puzzle. We are given a list of numbers per line that we need to either <em>add</em> or <em>multiply</em> to get to a target number. I chose to use some recursion to solve this problem. Each iteration of the recursion will reduce the array of numbers using one of the operations.</p><p>In the end the list of numbers will be reduced to either the target number, or something else. So the base case checks to see if it was successful.</p><p>If the base case is not hit, the first recursion is to add the numbers. A trick here is to use a <code>LongStream</code> to range over <code>1</code> to the end, mapping the numbers. If number <code>1</code> is mapped, we add the number at position <code>0</code> to reduce the array.</p><p>The second case applies the multiplication in the same way.</p><p>The third case (part 2) is to concatenate the numbers, this is easil done through <code>number + "" + number</code> in java, coercing the numbers into a <code>String</code> and then using <code>Long.valueOf()</code> to read the value again.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f38ba8>boolean</span> <span style=color:#89b4fa>isValid</span>(<span style=color:#f38ba8>long</span> target, <span style=color:#f38ba8>long</span><span style=color:#89dceb;font-weight:700>[]</span> numbers, <span style=color:#f38ba8>boolean</span> third) {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> (numbers.<span style=color:#89b4fa>length</span> <span style=color:#89dceb;font-weight:700>==</span> 1) <span style=color:#cba6f7>return</span> target <span style=color:#89dceb;font-weight:700>==</span> numbers<span style=color:#89dceb;font-weight:700>[</span>0<span style=color:#89dceb;font-weight:700>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> (isValid(target, LongStream.<span style=color:#89b4fa>range</span>(1, numbers.<span style=color:#89b4fa>length</span>)
</span></span><span style=display:flex><span>                .<span style=color:#89b4fa>map</span>(i <span style=color:#89dceb;font-weight:700>-&gt;</span> {
</span></span><span style=display:flex><span>                        <span style=color:#cba6f7>if</span> (i <span style=color:#89dceb;font-weight:700>==</span> 1) <span style=color:#cba6f7>return</span> numbers<span style=color:#89dceb;font-weight:700>[</span>0<span style=color:#89dceb;font-weight:700>]</span> <span style=color:#89dceb;font-weight:700>+</span> numbers<span style=color:#89dceb;font-weight:700>[</span>1<span style=color:#89dceb;font-weight:700>]</span>;
</span></span><span style=display:flex><span>                        <span style=color:#cba6f7>return</span> numbers<span style=color:#89dceb;font-weight:700>[</span>(<span style=color:#f38ba8>int</span>)i<span style=color:#89dceb;font-weight:700>]</span>;
</span></span><span style=display:flex><span>                    })
</span></span><span style=display:flex><span>                .<span style=color:#89b4fa>toArray</span>(), third)) <span style=color:#cba6f7>return</span> <span style=color:#fab387>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> (isValid(target, LongStream.<span style=color:#89b4fa>range</span>(1, numbers.<span style=color:#89b4fa>length</span>)
</span></span><span style=display:flex><span>                .<span style=color:#89b4fa>map</span>(i <span style=color:#89dceb;font-weight:700>-&gt;</span> {
</span></span><span style=display:flex><span>                        <span style=color:#cba6f7>if</span> (i <span style=color:#89dceb;font-weight:700>==</span> 1) <span style=color:#cba6f7>return</span> numbers<span style=color:#89dceb;font-weight:700>[</span>0<span style=color:#89dceb;font-weight:700>]</span> <span style=color:#89dceb;font-weight:700>*</span> numbers<span style=color:#89dceb;font-weight:700>[</span>1<span style=color:#89dceb;font-weight:700>]</span>;
</span></span><span style=display:flex><span>                        <span style=color:#cba6f7>return</span> numbers<span style=color:#89dceb;font-weight:700>[</span>(<span style=color:#f38ba8>int</span>)i<span style=color:#89dceb;font-weight:700>]</span>;
</span></span><span style=display:flex><span>                    })
</span></span><span style=display:flex><span>                .<span style=color:#89b4fa>toArray</span>(), third)) <span style=color:#cba6f7>return</span> <span style=color:#fab387>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> (third <span style=color:#89dceb;font-weight:700>&amp;&amp;</span> isValid(target, LongStream.<span style=color:#89b4fa>range</span>(1, numbers.<span style=color:#89b4fa>length</span>)
</span></span><span style=display:flex><span>                          .<span style=color:#89b4fa>map</span>(i <span style=color:#89dceb;font-weight:700>-&gt;</span> {
</span></span><span style=display:flex><span>                                  <span style=color:#cba6f7>if</span> (i <span style=color:#89dceb;font-weight:700>==</span> 1) <span style=color:#cba6f7>return</span> Long.<span style=color:#89b4fa>valueOf</span>(numbers<span style=color:#89dceb;font-weight:700>[</span>0<span style=color:#89dceb;font-weight:700>]</span> <span style=color:#89dceb;font-weight:700>+</span> <span style=color:#a6e3a1>&#34;&#34;</span> <span style=color:#89dceb;font-weight:700>+</span> numbers<span style=color:#89dceb;font-weight:700>[</span>1<span style=color:#89dceb;font-weight:700>]</span>);
</span></span><span style=display:flex><span>                                  <span style=color:#cba6f7>return</span> numbers<span style=color:#89dceb;font-weight:700>[</span>(<span style=color:#f38ba8>int</span>)i<span style=color:#89dceb;font-weight:700>]</span>;
</span></span><span style=display:flex><span>                              })
</span></span><span style=display:flex><span>                          .<span style=color:#89b4fa>toArray</span>(), third)) <span style=color:#cba6f7>return</span> <span style=color:#fab387>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> <span style=color:#fab387>false</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>One last trick is to use the <code>Stream</code> feature to <code>filter</code> the list, mapping each object to a long value and summing.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#89b4fa;font-weight:700>@Override</span> <span style=color:#f38ba8>public</span> Long <span style=color:#89b4fa>solver1</span>(List<span style=color:#89dceb;font-weight:700>&lt;</span>Calibration<span style=color:#89dceb;font-weight:700>&gt;</span> input) {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> input.<span style=color:#89b4fa>stream</span>().<span style=color:#89b4fa>filter</span>(i <span style=color:#89dceb;font-weight:700>-&gt;</span> isValid(i.<span style=color:#89b4fa>target</span>, i.<span style=color:#89b4fa>numbers</span>, <span style=color:#fab387>false</span>)).<span style=color:#89b4fa>mapToLong</span>(cal <span style=color:#89dceb;font-weight:700>-&gt;</span> cal.<span style=color:#89b4fa>target</span>).<span style=color:#89b4fa>sum</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=day-8>Day 8<a hidden class=anchor aria-hidden=true href=#day-8>#</a></h2><p>Day 8 has us back in history staring at antennas. The description was quite cryptic, but reading it carefully you learn that the necessary step is to find the difference between a pair of coordinates and then extrapolate the path inside the bounds of the grid.</p><p>To read the grid into a structure I used a simple nested loop, adding a new list to the map if it is absent, then adding the new coordinate for the antenna.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#cba6f7>for</span> (<span style=color:#f38ba8>int</span> r <span style=color:#89dceb;font-weight:700>=</span> 0; r <span style=color:#89dceb;font-weight:700>&lt;</span> gridH; r<span style=color:#89dceb;font-weight:700>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>for</span> (<span style=color:#f38ba8>int</span> c <span style=color:#89dceb;font-weight:700>=</span> 0; c <span style=color:#89dceb;font-weight:700>&lt;</span> gridW; c<span style=color:#89dceb;font-weight:700>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>char</span> ch <span style=color:#89dceb;font-weight:700>=</span> input.<span style=color:#89b4fa>get</span>(r).<span style=color:#89b4fa>charAt</span>(c);
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> (ch <span style=color:#89dceb;font-weight:700>!=</span> <span style=color:#a6e3a1>&#39;.&#39;</span>) {
</span></span><span style=display:flex><span>            antennas.<span style=color:#89b4fa>computeIfAbsent</span>(ch, k <span style=color:#89dceb;font-weight:700>-&gt;</span> <span style=color:#cba6f7>new</span> ArrayList<span style=color:#89dceb;font-weight:700>&lt;&gt;</span>()).<span style=color:#89b4fa>add</span>(<span style=color:#cba6f7>new</span> Coord(c, r));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We then have to find the <code>antinode</code> for the point which, for the pair, is just a single difference step from the antenna. Interestingly we need to count the <strong><strong>unique</strong></strong> antinodes. Whenever you get such a requirement, always think about using a <code>Set</code> for storage.</p><p>Getting the pairs is straightforward, and we have done it earlier in the series already. The first loop starts at <code>0</code> and ends the element before the end, <code>size - 1</code>. The inner loop starts at <code>current pos + 1</code> and ends at the size of the list.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#cba6f7>for</span> (<span style=color:#f38ba8>int</span> p <span style=color:#89dceb;font-weight:700>=</span> 0; p <span style=color:#89dceb;font-weight:700>&lt;</span> coords.<span style=color:#89b4fa>size</span>() <span style=color:#89dceb;font-weight:700>-</span> 1; p<span style=color:#89dceb;font-weight:700>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>for</span> (<span style=color:#f38ba8>int</span> n <span style=color:#89dceb;font-weight:700>=</span> p <span style=color:#89dceb;font-weight:700>+</span> 1; n <span style=color:#89dceb;font-weight:700>&lt;</span> coords.<span style=color:#89b4fa>size</span>(); n<span style=color:#89dceb;font-weight:700>++</span>) {
</span></span></code></pre></div><p>Then just compute the difference and add the antinode when it is in bounds.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f38ba8>var</span> antinode1 <span style=color:#89dceb;font-weight:700>=</span> cur.<span style=color:#89b4fa>add</span>(cur.<span style=color:#89b4fa>diff</span>(next));
</span></span><span style=display:flex><span><span style=color:#f38ba8>var</span> antinode2 <span style=color:#89dceb;font-weight:700>=</span> next.<span style=color:#89b4fa>add</span>(next.<span style=color:#89b4fa>diff</span>(cur));
</span></span></code></pre></div><p>In part 2 the path needs to be extrapolated until it goes out of bounds. This can easily be wrapped in its own method.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f38ba8>void</span> <span style=color:#89b4fa>addAntinodesInDirection</span>(Set<span style=color:#89dceb;font-weight:700>&lt;</span>Coord<span style=color:#89dceb;font-weight:700>&gt;</span> antinodes, Coord start, Coord diff) {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> current <span style=color:#89dceb;font-weight:700>=</span> start;
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>while</span> (<span style=color:#fab387>true</span>) {
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>var</span> next <span style=color:#89dceb;font-weight:700>=</span> current.<span style=color:#89b4fa>add</span>(diff);
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> (<span style=color:#89dceb;font-weight:700>!</span>next.<span style=color:#89b4fa>inBound</span>(0, gridW, 0, gridH)) {
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        antinodes.<span style=color:#89b4fa>add</span>(next);
</span></span><span style=display:flex><span>        current <span style=color:#89dceb;font-weight:700>=</span> next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A pretty straightforward problem to solve, on to tomorrow!</p><h2 id=day-9>Day 9<a hidden class=anchor aria-hidden=true href=#day-9>#</a></h2><p>For me this was a hard day. We are given a list of numbers that we use to fragment files on a disk. The first part of the puzzle was quite straightforward, create a list that holds the file ids and spaces and just follow the rules.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#cba6f7>for</span> (<span style=color:#f38ba8>int</span> i <span style=color:#89dceb;font-weight:700>=</span> 0; i <span style=color:#89dceb;font-weight:700>&lt;</span> input.<span style=color:#89b4fa>length</span>(); i<span style=color:#89dceb;font-weight:700>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>for</span> (<span style=color:#f38ba8>int</span> j <span style=color:#89dceb;font-weight:700>=</span> 0; j <span style=color:#89dceb;font-weight:700>&lt;</span> input.<span style=color:#89b4fa>charAt</span>(i)<span style=color:#89dceb;font-weight:700>-</span><span style=color:#a6e3a1>&#39;0&#39;</span>; j<span style=color:#89dceb;font-weight:700>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> (i<span style=color:#89dceb;font-weight:700>%</span>2 <span style=color:#89dceb;font-weight:700>==</span> 0) {
</span></span><span style=display:flex><span>            disk.<span style=color:#89b4fa>add</span>(id);
</span></span><span style=display:flex><span>        } <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>            disk.<span style=color:#89b4fa>add</span>(<span style=color:#fab387>null</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> (i<span style=color:#89dceb;font-weight:700>%</span>2 <span style=color:#89dceb;font-weight:700>==</span> 0) {
</span></span><span style=display:flex><span>        id<span style=color:#89dceb;font-weight:700>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>From there just create 2 pointers, one on the left and one on the right. The left tracks the empty space and the right tracks the file ids that we want to put in the empty space. The important thing in Java is to make the implementation of the list a <code>LinkedList</code>. This allows for little-overhead reshuffling of the list.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f38ba8>var</span> l <span style=color:#89dceb;font-weight:700>=</span> 0;
</span></span><span style=display:flex><span><span style=color:#f38ba8>var</span> r <span style=color:#89dceb;font-weight:700>=</span> disk.<span style=color:#89b4fa>size</span>() <span style=color:#89dceb;font-weight:700>-</span> 1;
</span></span><span style=display:flex><span><span style=color:#cba6f7>while</span> (l <span style=color:#89dceb;font-weight:700>&lt;</span> r) {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> (disk.<span style=color:#89b4fa>get</span>(l) <span style=color:#89dceb;font-weight:700>!=</span> <span style=color:#fab387>null</span>) {
</span></span><span style=display:flex><span>        l<span style=color:#89dceb;font-weight:700>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> (disk.<span style=color:#89b4fa>get</span>(r) <span style=color:#89dceb;font-weight:700>==</span> <span style=color:#fab387>null</span>) {
</span></span><span style=display:flex><span>        r<span style=color:#89dceb;font-weight:700>--</span>;
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    disk.<span style=color:#89b4fa>set</span>(l, disk.<span style=color:#89b4fa>get</span>(r));
</span></span><span style=display:flex><span>    disk.<span style=color:#89b4fa>set</span>(r, <span style=color:#fab387>null</span>);
</span></span><span style=display:flex><span>    l<span style=color:#89dceb;font-weight:700>++</span>;
</span></span><span style=display:flex><span>    r<span style=color:#89dceb;font-weight:700>--</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Part 2 became much harder, we are not to find space for the blocks of files instead of fragments. I first tried the same approach, but it took forever. I then saw the error of my ways and decided to use a lookup table for the empty spaces. This table maps the empty spaces of size <code>N</code>, in the below example 1 and 2, to a list of start/end coordinates.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>1 = [1,1] [2,2]
</span></span><span style=display:flex><span>2 = [3,4] [6,7]
</span></span></code></pre></div><p>The list of coordinates needs to remain sorted, so I used a <code>PriorityQueue</code> for it. Then it is just a matter of determining the size of the file under the <code>r</code> pointer by looping over it until we hit another id, and then looking up the most left candidate of the empty spaces.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Gets all candidates that will fit the file</span>
</span></span><span style=display:flex><span><span style=color:#cba6f7>for</span> (<span style=color:#f38ba8>int</span> i <span style=color:#89dceb;font-weight:700>=</span> bs; i <span style=color:#89dceb;font-weight:700>&lt;</span> 10; i<span style=color:#89dceb;font-weight:700>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> earliest <span style=color:#89dceb;font-weight:700>=</span> free<span style=color:#89dceb;font-weight:700>[</span>i<span style=color:#89dceb;font-weight:700>]</span>.<span style=color:#89b4fa>peek</span>();
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> (earliest <span style=color:#89dceb;font-weight:700>!=</span> <span style=color:#fab387>null</span> <span style=color:#89dceb;font-weight:700>&amp;&amp;</span> earliest <span style=color:#89dceb;font-weight:700>&lt;</span> r) {
</span></span><span style=display:flex><span>        candidates.<span style=color:#89b4fa>add</span>(<span style=color:#cba6f7>new</span> Candidate(i, earliest));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cba6f7>if</span> (candidates.<span style=color:#89b4fa>isEmpty</span>()) {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> <span style=color:#fab387>null</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Sort based on the index (most left first)</span>
</span></span><span style=display:flex><span>candidates.<span style=color:#89b4fa>sort</span>((lhs, rhs) <span style=color:#89dceb;font-weight:700>-&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> lhs.<span style=color:#89b4fa>idx</span>() <span style=color:#89dceb;font-weight:700>-</span> rhs.<span style=color:#89b4fa>idx</span>();
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>var</span> can <span style=color:#89dceb;font-weight:700>=</span> candidates.<span style=color:#89b4fa>getFirst</span>();
</span></span><span style=display:flex><span>free<span style=color:#89dceb;font-weight:700>[</span>can.<span style=color:#89b4fa>size</span>()<span style=color:#89dceb;font-weight:700>]</span>.<span style=color:#89b4fa>remove</span>();
</span></span></code></pre></div><p>The final solution runs in a matter of milliseconds, so I am quite happy with that.</p><h2 id=day-10>Day 10<a hidden class=anchor aria-hidden=true href=#day-10>#</a></h2><p>Finally a depth first / breath first path seeker! We need to identify a trail that leads to a summit, or rather all trails that lead to the summit. Part 1 wants to know the score (how many summits can a path reach) and part 2 its rating (how many trails are there that reach a summit). This is pretty straightforward in the sense that you create a <code>Queue</code> and put the start of the trail in, then for each direction you construct a more complete path.</p><p>As always it is important to check for bounds and if the path is incremental (business rule). If the new path is actually at the summit, add it to the finished paths. If it is not, try to complete it.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Trail <span style=color:#89b4fa>solve</span>(<span style=color:#f38ba8>char</span><span style=color:#89dceb;font-weight:700>[][]</span> grid, Coord zero) {
</span></span><span style=display:flex><span><span style=color:#f38ba8>var</span> q <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>new</span> ArrayDeque<span style=color:#89dceb;font-weight:700>&lt;</span>List<span style=color:#89dceb;font-weight:700>&lt;</span>Coord<span style=color:#89dceb;font-weight:700>&gt;&gt;</span>();
</span></span><span style=display:flex><span>q.<span style=color:#89b4fa>add</span>(List.<span style=color:#89b4fa>of</span>(zero));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>List<span style=color:#89dceb;font-weight:700>&lt;</span>List<span style=color:#89dceb;font-weight:700>&lt;</span>Coord<span style=color:#89dceb;font-weight:700>&gt;&gt;</span> paths <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>new</span> ArrayList<span style=color:#89dceb;font-weight:700>&lt;&gt;</span>();
</span></span><span style=display:flex><span><span style=color:#cba6f7>while</span> (<span style=color:#89dceb;font-weight:700>!</span>q.<span style=color:#89b4fa>isEmpty</span>()) {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> current <span style=color:#89dceb;font-weight:700>=</span> q.<span style=color:#89b4fa>removeFirst</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>for</span> (Coord d : zero.<span style=color:#89b4fa>directNeighbors</span>()) {
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>var</span> last <span style=color:#89dceb;font-weight:700>=</span> current.<span style=color:#89b4fa>getLast</span>();
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>var</span> nc <span style=color:#89dceb;font-weight:700>=</span> last.<span style=color:#89b4fa>add</span>(d);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> (<span style=color:#89dceb;font-weight:700>!</span>nc.<span style=color:#89b4fa>inBound</span>(0,grid<span style=color:#89dceb;font-weight:700>[</span>0<span style=color:#89dceb;font-weight:700>]</span>.<span style=color:#89b4fa>length</span>, 0, grid.<span style=color:#89b4fa>length</span>)) <span style=color:#cba6f7>continue</span>;
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> (grid<span style=color:#89dceb;font-weight:700>[</span>nc.<span style=color:#89b4fa>y</span>()<span style=color:#89dceb;font-weight:700>][</span>nc.<span style=color:#89b4fa>x</span>()<span style=color:#89dceb;font-weight:700>]</span> <span style=color:#89dceb;font-weight:700>!=</span> grid<span style=color:#89dceb;font-weight:700>[</span>last.<span style=color:#89b4fa>y</span>()<span style=color:#89dceb;font-weight:700>][</span>last.<span style=color:#89b4fa>x</span>()<span style=color:#89dceb;font-weight:700>]</span> <span style=color:#89dceb;font-weight:700>+</span> 1) <span style=color:#cba6f7>continue</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>var</span> newPath <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>new</span> ArrayList<span style=color:#89dceb;font-weight:700>&lt;&gt;</span>(current);
</span></span><span style=display:flex><span>        newPath.<span style=color:#89b4fa>add</span>(nc);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> (grid<span style=color:#89dceb;font-weight:700>[</span>nc.<span style=color:#89b4fa>y</span>()<span style=color:#89dceb;font-weight:700>][</span>nc.<span style=color:#89b4fa>x</span>()<span style=color:#89dceb;font-weight:700>]</span> <span style=color:#89dceb;font-weight:700>==</span> <span style=color:#a6e3a1>&#39;9&#39;</span>) {
</span></span><span style=display:flex><span>            paths.<span style=color:#89b4fa>add</span>(newPath);
</span></span><span style=display:flex><span>        } <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>            q.<span style=color:#89b4fa>addLast</span>(newPath);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#f38ba8>var</span> score <span style=color:#89dceb;font-weight:700>=</span> paths.<span style=color:#89b4fa>stream</span>().<span style=color:#89b4fa>map</span>(l<span style=color:#89dceb;font-weight:700>-&gt;</span>l.<span style=color:#89b4fa>getLast</span>()).<span style=color:#89b4fa>collect</span>(Collectors.<span style=color:#89b4fa>toSet</span>()).<span style=color:#89b4fa>size</span>();
</span></span><span style=display:flex><span><span style=color:#f38ba8>var</span> rating <span style=color:#89dceb;font-weight:700>=</span> paths.<span style=color:#89b4fa>size</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cba6f7>return</span> <span style=color:#cba6f7>new</span> Trail(score, rating);
</span></span></code></pre></div><h2 id=day-11-one-to-remember>Day 11 - one to remember<a hidden class=anchor aria-hidden=true href=#day-11-one-to-remember>#</a></h2><p>For the last couple of days the discussion forums have been full with memes about brute forcing the answer. Up to now you could really do so. I have one colleague who wrote a nice brute force for <a href=#day-6>Day 6</a> that took several minutes, but it did work. Personally I am not a fan of the brute forcing approach, I like to make it more elegant when possible.</p><p>Today is this years first <a href=https://adventofcode.com/2021/day/6>Lanternfish</a> type of problem, one where the problem space becomes so large that your computer is not able to brute force it due to memory constraints. It calls for a more elegant solution.</p><p>Part 1 and part 2 are basically the same, the difference is the amount of iterations for the problem. In this case we have some rules in which rocks change and split up. We are tasked to find the amount of rocks after <code>25</code> and <code>75</code> iterations. The first is do-able with a brute force approach, the second is not.</p><p>The rules are straightforward, but the solution to the problem space might not be. The trick is to use something called <code>memoization</code>.</p><blockquote><p>In computing, memoization or memoisation is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls to pure functions and returning the cached result when the same inputs occur again.</p></blockquote><p>So, basically we store results of method calls. Lets first look at my solution. It is a recursive function that takes a <code>number</code> and the number of <code>iterations</code> to apply to it.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#cba6f7>if</span> (iterations <span style=color:#89dceb;font-weight:700>==</span> 0) <span style=color:#cba6f7>return</span> 1;
</span></span><span style=display:flex><span><span style=color:#f38ba8>var</span> cache <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>new</span> Cache(number,iterations);
</span></span><span style=display:flex><span><span style=color:#cba6f7>if</span> (memo.<span style=color:#89b4fa>containsKey</span>(cache)) {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> memo.<span style=color:#89b4fa>get</span>(cache);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#cba6f7>if</span> (number <span style=color:#89dceb;font-weight:700>==</span> 0) {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>long</span> l <span style=color:#89dceb;font-weight:700>=</span> ways(1, iterations <span style=color:#89dceb;font-weight:700>-</span> 1, memo);
</span></span><span style=display:flex><span>    memo.<span style=color:#89b4fa>put</span>(cache, l);
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> l;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>String s <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#a6e3a1>&#34;&#34;</span> <span style=color:#89dceb;font-weight:700>+</span> number;
</span></span><span style=display:flex><span><span style=color:#f38ba8>int</span> l <span style=color:#89dceb;font-weight:700>=</span> s.<span style=color:#89b4fa>length</span>();
</span></span><span style=display:flex><span><span style=color:#cba6f7>if</span> (l <span style=color:#89dceb;font-weight:700>%</span> 2 <span style=color:#89dceb;font-weight:700>==</span> 0) {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>long</span> c <span style=color:#89dceb;font-weight:700>=</span> ways(Long.<span style=color:#89b4fa>parseLong</span>(s.<span style=color:#89b4fa>substring</span>(0,l<span style=color:#89dceb;font-weight:700>/</span>2)), iterations<span style=color:#89dceb;font-weight:700>-</span>1, memo) <span style=color:#89dceb;font-weight:700>+</span> ways(Long.<span style=color:#89b4fa>parseLong</span>(s.<span style=color:#89b4fa>substring</span>(l<span style=color:#89dceb;font-weight:700>/</span>2,l)), iterations<span style=color:#89dceb;font-weight:700>-</span>1, memo);
</span></span><span style=display:flex><span>    memo.<span style=color:#89b4fa>put</span>(cache, c);
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> c;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#f38ba8>long</span> c <span style=color:#89dceb;font-weight:700>=</span>  ways(number <span style=color:#89dceb;font-weight:700>*</span> 2024, iterations<span style=color:#89dceb;font-weight:700>-</span>1, memo);
</span></span><span style=display:flex><span>memo.<span style=color:#89b4fa>put</span>(cache, c);
</span></span><span style=display:flex><span><span style=color:#cba6f7>return</span> c;
</span></span></code></pre></div><p>For this call the result is stored in a <code>memo</code>, a simple <code>HashMap</code> that stores the method arguments in a <code>CacheKey</code> and then stores the count, the result of the recursive call. What happens here is that there might be many different calls to this method, such as <code>(9,23)</code>. In this case the number 9 has 23 iterations to go. By computing the result once and then storing the computed value we save the time of doing the same calculations many other times.</p><p>This was a really fun and relatively quick challenge, greatly enjoyed it!</p><h2 id=day-12-garden-groups>Day 12 - Garden Groups<a hidden class=anchor aria-hidden=true href=#day-12-garden-groups>#</a></h2><p>This day had me stumped for quite a time. The puzzle starts off with a simple question; group the garden (grid) into areas that are the same and count the fences required. A simple flood fill type of solution works very well here.</p><p>Whenever a neighbor is not the same type (or we are the edge), a fence is required. If it is the same type, add it to the queue for further processing.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#cba6f7>for</span> (<span style=color:#f38ba8>int</span> r <span style=color:#89dceb;font-weight:700>=</span> 0; r <span style=color:#89dceb;font-weight:700>&lt;</span> input.<span style=color:#89b4fa>length</span>; r<span style=color:#89dceb;font-weight:700>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>for</span> (<span style=color:#f38ba8>int</span> c <span style=color:#89dceb;font-weight:700>=</span> 0; c <span style=color:#89dceb;font-weight:700>&lt;</span> input<span style=color:#89dceb;font-weight:700>[</span>r<span style=color:#89dceb;font-weight:700>]</span>.<span style=color:#89b4fa>length</span>; c<span style=color:#89dceb;font-weight:700>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>var</span> start <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>new</span> Coord(c, r);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> (<span style=color:#89dceb;font-weight:700>!</span>seen.<span style=color:#89b4fa>add</span>(start)) {
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>var</span> queue <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>new</span> ArrayDeque<span style=color:#89dceb;font-weight:700>&lt;</span>Coord<span style=color:#89dceb;font-weight:700>&gt;</span>();
</span></span><span style=display:flex><span>        queue.<span style=color:#89b4fa>add</span>(start);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>var</span> cells <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>new</span> HashSet<span style=color:#89dceb;font-weight:700>&lt;</span>Coord<span style=color:#89dceb;font-weight:700>&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>int</span> perimeter <span style=color:#89dceb;font-weight:700>=</span> 0;
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>char</span> fenceType <span style=color:#89dceb;font-weight:700>=</span> input<span style=color:#89dceb;font-weight:700>[</span>r<span style=color:#89dceb;font-weight:700>][</span>c<span style=color:#89dceb;font-weight:700>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>while</span> (<span style=color:#89dceb;font-weight:700>!</span>queue.<span style=color:#89b4fa>isEmpty</span>()) {
</span></span><span style=display:flex><span>            Coord cell <span style=color:#89dceb;font-weight:700>=</span> queue.<span style=color:#89b4fa>poll</span>();
</span></span><span style=display:flex><span>            cells.<span style=color:#89b4fa>add</span>(cell);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>for</span> (Coord neighbor : Coord.<span style=color:#89b4fa>directNeighbors</span>()) {
</span></span><span style=display:flex><span>                Coord next <span style=color:#89dceb;font-weight:700>=</span> cell.<span style=color:#89b4fa>add</span>(neighbor);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#cba6f7>if</span> (<span style=color:#89dceb;font-weight:700>!</span>next.<span style=color:#89b4fa>inBound</span>(0, input<span style=color:#89dceb;font-weight:700>[</span>0<span style=color:#89dceb;font-weight:700>]</span>.<span style=color:#89b4fa>length</span>, 0, input.<span style=color:#89b4fa>length</span>) <span style=color:#89dceb;font-weight:700>||</span>
</span></span><span style=display:flex><span>                    input<span style=color:#89dceb;font-weight:700>[</span>next.<span style=color:#89b4fa>y</span>()<span style=color:#89dceb;font-weight:700>][</span>next.<span style=color:#89b4fa>x</span>()<span style=color:#89dceb;font-weight:700>]</span> <span style=color:#89dceb;font-weight:700>!=</span> fenceType) {
</span></span><span style=display:flex><span>                    perimeter<span style=color:#89dceb;font-weight:700>++</span>;
</span></span><span style=display:flex><span>                } <span style=color:#cba6f7>else</span> <span style=color:#cba6f7>if</span> (seen.<span style=color:#89b4fa>add</span>(next)) {
</span></span><span style=display:flex><span>                    queue.<span style=color:#89b4fa>add</span>(next);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        fences.<span style=color:#89b4fa>add</span>(<span style=color:#cba6f7>new</span> Fence(perimeter, cells));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The next part had me going for a little bit. Instead of the area or fences the elves need the sides counted. This turns out to be quite a thing until it becomes clear that counting corners also works.</p><p>Lets say the below map is our grid. When looking at the <code>A</code> in cell <code>0,2</code> it is possible to check if it is a corner by checking that the cell above it and the cell to the right are not the same. The same goes for the cell below and the cell to the right.</p><figure><img loading=lazy src=/ox-hugo/corners.png></figure><p>A neat trick to find the sides to an area. The code turned out to be relatively easy:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#cba6f7>for</span> (<span style=color:#f38ba8>var</span> cell : fence.<span style=color:#89b4fa>cells</span>()) {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>char</span> curr <span style=color:#89dceb;font-weight:700>=</span> input<span style=color:#89dceb;font-weight:700>[</span>cell.<span style=color:#89b4fa>y</span>()<span style=color:#89dceb;font-weight:700>][</span>cell.<span style=color:#89b4fa>x</span>()<span style=color:#89dceb;font-weight:700>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>for</span> (<span style=color:#f38ba8>int</span> ud : <span style=color:#cba6f7>new</span> <span style=color:#f38ba8>int</span><span style=color:#89dceb;font-weight:700>[]</span>{<span style=color:#89dceb;font-weight:700>-</span>1, 1}) {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>for</span> (<span style=color:#f38ba8>int</span> lr : <span style=color:#cba6f7>new</span> <span style=color:#f38ba8>int</span><span style=color:#89dceb;font-weight:700>[]</span>{<span style=color:#89dceb;font-weight:700>-</span>1, 1}) {
</span></span><span style=display:flex><span>            <span style=color:#f38ba8>int</span> ny <span style=color:#89dceb;font-weight:700>=</span> cell.<span style=color:#89b4fa>y</span>() <span style=color:#89dceb;font-weight:700>+</span> ud;
</span></span><span style=display:flex><span>            <span style=color:#f38ba8>int</span> nx <span style=color:#89dceb;font-weight:700>=</span> cell.<span style=color:#89b4fa>x</span>() <span style=color:#89dceb;font-weight:700>+</span> lr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#f38ba8>boolean</span> outOfBoundsY <span style=color:#89dceb;font-weight:700>=</span> ny <span style=color:#89dceb;font-weight:700>&lt;</span> 0 <span style=color:#89dceb;font-weight:700>||</span> ny <span style=color:#89dceb;font-weight:700>&gt;=</span> input.<span style=color:#89b4fa>length</span>;
</span></span><span style=display:flex><span>            <span style=color:#f38ba8>boolean</span> outOfBoundsX <span style=color:#89dceb;font-weight:700>=</span> nx <span style=color:#89dceb;font-weight:700>&lt;</span> 0 <span style=color:#89dceb;font-weight:700>||</span> nx <span style=color:#89dceb;font-weight:700>&gt;=</span> input<span style=color:#89dceb;font-weight:700>[</span>0<span style=color:#89dceb;font-weight:700>]</span>.<span style=color:#89b4fa>length</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>if</span> ((outOfBoundsY <span style=color:#89dceb;font-weight:700>||</span> input<span style=color:#89dceb;font-weight:700>[</span>ny<span style=color:#89dceb;font-weight:700>][</span>cell.<span style=color:#89b4fa>x</span>()<span style=color:#89dceb;font-weight:700>]</span> <span style=color:#89dceb;font-weight:700>!=</span> curr) <span style=color:#89dceb;font-weight:700>&amp;&amp;</span>
</span></span><span style=display:flex><span>                (outOfBoundsX <span style=color:#89dceb;font-weight:700>||</span> input<span style=color:#89dceb;font-weight:700>[</span>cell.<span style=color:#89b4fa>y</span>()<span style=color:#89dceb;font-weight:700>][</span>nx<span style=color:#89dceb;font-weight:700>]</span> <span style=color:#89dceb;font-weight:700>!=</span> curr)) {
</span></span><span style=display:flex><span>                corners<span style=color:#89dceb;font-weight:700>++</span>;
</span></span><span style=display:flex><span>            } <span style=color:#cba6f7>else</span> <span style=color:#cba6f7>if</span> (<span style=color:#89dceb;font-weight:700>!</span>outOfBoundsY <span style=color:#89dceb;font-weight:700>&amp;&amp;</span> <span style=color:#89dceb;font-weight:700>!</span>outOfBoundsX <span style=color:#89dceb;font-weight:700>&amp;&amp;</span>
</span></span><span style=display:flex><span>                        input<span style=color:#89dceb;font-weight:700>[</span>ny<span style=color:#89dceb;font-weight:700>][</span>cell.<span style=color:#89b4fa>x</span>()<span style=color:#89dceb;font-weight:700>]</span> <span style=color:#89dceb;font-weight:700>==</span> curr <span style=color:#89dceb;font-weight:700>&amp;&amp;</span>
</span></span><span style=display:flex><span>                        input<span style=color:#89dceb;font-weight:700>[</span>cell.<span style=color:#89b4fa>y</span>()<span style=color:#89dceb;font-weight:700>][</span>nx<span style=color:#89dceb;font-weight:700>]</span> <span style=color:#89dceb;font-weight:700>==</span> curr <span style=color:#89dceb;font-weight:700>&amp;&amp;</span>
</span></span><span style=display:flex><span>                        input<span style=color:#89dceb;font-weight:700>[</span>ny<span style=color:#89dceb;font-weight:700>][</span>nx<span style=color:#89dceb;font-weight:700>]</span> <span style=color:#89dceb;font-weight:700>!=</span> curr) {
</span></span><span style=display:flex><span>                corners<span style=color:#89dceb;font-weight:700>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>On to Friday the 13th!</p><h2 id=day-13-claw-contraption>Day 13 - Claw Contraption<a hidden class=anchor aria-hidden=true href=#day-13-claw-contraption>#</a></h2><p>Today was quite something. We have claw machines that have 2 buttons. The buttons move the arm a set space on the <code>x</code> and <code>y</code> coordinates. Both buttons have a different value for the cost and we are tasked to find the cheapest path to a prize on some distant <code>x</code> and <code>y</code> location.</p><p>My initial solution was naive and used dynamic programming to solve it. It did not adhere to the rule <em>every problem has a solution that completes in at most 15 seconds on ten-year-old hardware</em>. So eventually I found a solution (thanks Hyperneutrino!) that uses math to solve this problem.</p><p>Basically we are trying to find the amount of <code>x</code> and <code>y</code> movements both the A button (indicated by <code>S</code>) and the B button (indicated by <code>T</code>) have to make in order to get to the prize <code>x</code> and <code>y</code> values.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>axS + bxT = px
</span></span><span style=display:flex><span>ayS + byT = py
</span></span></code></pre></div><p>We can make these equations the same by multiplying with <code>by</code> and <code>bx</code>. We do this so we can remove the B button from the equation and solve A.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>axbyS + bxbyT = pxby
</span></span><span style=display:flex><span>aybxS + bybxT = pybx
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Now bxbyT == bxbyT
</span></span></code></pre></div><p>This can then be rewritten in a single equation, from which we can isolate A.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>axbyS - aybxS = pxby - pybx
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(axby-aybx)S =  pxby - pybx
</span></span></code></pre></div><p>Now we can divide by <code>axby - aybx</code> and get our solution for A. We have to ensure the input is never <code>0</code> to prevent division by zero. In the code we can check this by checking that <code>ax * by == ay * bx</code> never occurs.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>S = pxby - pybx
</span></span><span style=display:flex><span>    -----------
</span></span><span style=display:flex><span>    axby - aybx
</span></span></code></pre></div><p>As we now have the A button value, we can also solve the B button.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>axS + bxT = px
</span></span><span style=display:flex><span>bxT = px - axS
</span></span><span style=display:flex><span>T = px-axS
</span></span><span style=display:flex><span>    ------
</span></span><span style=display:flex><span>    bx
</span></span></code></pre></div><p>In code the solution looks very simple. Notice the <code>ca%1==0 && cb%1==0</code> check to ensure we do not allow for fractional steps.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f38ba8>private</span> <span style=color:#f38ba8>long</span> <span style=color:#89b4fa>solve</span>(<span style=color:#f38ba8>double</span> ax, <span style=color:#f38ba8>double</span> ay, <span style=color:#f38ba8>double</span> bx, <span style=color:#f38ba8>double</span> by, <span style=color:#f38ba8>long</span> px, <span style=color:#f38ba8>long</span> py) {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>long</span> answer <span style=color:#89dceb;font-weight:700>=</span> 0L;
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>double</span> ca <span style=color:#89dceb;font-weight:700>=</span> (px <span style=color:#89dceb;font-weight:700>*</span> by <span style=color:#89dceb;font-weight:700>-</span> py <span style=color:#89dceb;font-weight:700>*</span> bx) <span style=color:#89dceb;font-weight:700>/</span> (ax <span style=color:#89dceb;font-weight:700>*</span> by <span style=color:#89dceb;font-weight:700>-</span> ay <span style=color:#89dceb;font-weight:700>*</span> bx);
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>double</span> cb <span style=color:#89dceb;font-weight:700>=</span> (px <span style=color:#89dceb;font-weight:700>-</span> ax <span style=color:#89dceb;font-weight:700>*</span> ca) <span style=color:#89dceb;font-weight:700>/</span> bx;
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> (ca <span style=color:#89dceb;font-weight:700>%</span> 1 <span style=color:#89dceb;font-weight:700>==</span> 0 <span style=color:#89dceb;font-weight:700>&amp;&amp;</span> cb <span style=color:#89dceb;font-weight:700>%</span> 1 <span style=color:#89dceb;font-weight:700>==</span> 0) {
</span></span><span style=display:flex><span>        answer <span style=color:#89dceb;font-weight:700>+=</span> (<span style=color:#f38ba8>long</span>) (ca<span style=color:#89dceb;font-weight:700>*</span>3) <span style=color:#89dceb;font-weight:700>+</span> cb;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> answer;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=day-14-restroom-redoubt>Day 14 - Restroom redoubt<a hidden class=anchor aria-hidden=true href=#day-14-restroom-redoubt>#</a></h2><p>Today we are back at Easter Bunny HQ, looking for a restroom. We are given a collection of robots, their current position on a grid and their velocity. The question becomes, where are they after 100 iterations (seconds)? An interesting part of this question is that the robots wrap around the grid.</p><p>This mechanic allows for very easy calculation of the final coordinates, as <code>(x + vx * 100) % width</code> will give us the final position, instead of having to go through all the calculations.</p><p>Interestingly, Java does not really like negative numbers in the modulo operator. For example, <code>-102 % 11</code> yields <code>-3</code> while it should yield <code>8</code> for it to be useful in our case. So, when the number is negative, just add the width to it.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#cba6f7>for</span> (<span style=color:#f38ba8>var</span> robot : robots) {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>int</span> newX <span style=color:#89dceb;font-weight:700>=</span> (robot.<span style=color:#89b4fa>start</span>.<span style=color:#89b4fa>x</span>() <span style=color:#89dceb;font-weight:700>+</span> robot.<span style=color:#89b4fa>vel</span>.<span style=color:#89b4fa>x</span>() <span style=color:#89dceb;font-weight:700>*</span> 100) <span style=color:#89dceb;font-weight:700>%</span> width;
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> (newX <span style=color:#89dceb;font-weight:700>&lt;</span> 0) newX <span style=color:#89dceb;font-weight:700>+=</span> width;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>int</span> newY <span style=color:#89dceb;font-weight:700>=</span> (robot.<span style=color:#89b4fa>start</span>.<span style=color:#89b4fa>y</span>() <span style=color:#89dceb;font-weight:700>+</span> robot.<span style=color:#89b4fa>vel</span>.<span style=color:#89b4fa>y</span>() <span style=color:#89dceb;font-weight:700>*</span> 100) <span style=color:#89dceb;font-weight:700>%</span> height;
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> (newY <span style=color:#89dceb;font-weight:700>&lt;</span> 0) newY <span style=color:#89dceb;font-weight:700>+=</span> height;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    positions.<span style=color:#89b4fa>merge</span>(<span style=color:#cba6f7>new</span> Coord(newX, newY), 1, Integer::sum);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Part 2 was a horrible puzzle. There was no clue what to do in order to get this:</p><figure><img loading=lazy src=/ox-hugo/day14.png></figure><p>I finally solved it by looking at the field when all robots are on a unique position. I also have seen solution where the minimum safety value is found. The problem description was:</p><blockquote><p>During the bathroom break, someone notices that these robots seem awfully similar to ones built and used at the North Pole. If they&rsquo;re the same type of robots, they should have a hard-coded Easter egg: very rarely, most of the robots should arrange themselves into a picture of a Christmas tree.</p><p>What is the fewest number of seconds that must elapse for the robots to display the Easter egg?</p></blockquote><p>Maybe if it had said &ldquo;very rarely, but when all the robots arrange themselves&rdquo;, but then again, how are you supposed to know that it means non-overlapping.</p><p>Love the Christmas tree though.</p><h2 id=day-15-warehouse-woes>Day 15 - Warehouse Woes<a hidden class=anchor aria-hidden=true href=#day-15-warehouse-woes>#</a></h2><p>Yay, the Lanternfish have made an appearance! Sadly this puzzle had me quite stumped for a while. I had to rewrite my solution 2 times in order to get it right.</p><p>First, let me explain. We are still not finding the historian (whom I think is just Eric in a costume). Instead we are on a side-quest helping our fishy friends with robots in their warehouses. The first puzzle is straightforward; move the player around, moving objects that you run into.</p><p>When we have that sorted we are sent to a second warehouse. This time the boxes that we move are twice as large, but the robot is still the same size. This means we get into situations as the following example:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>######
</span></span><span style=display:flex><span>#    #
</span></span><span style=display:flex><span># [] #
</span></span><span style=display:flex><span># @  #
</span></span><span style=display:flex><span>######
</span></span></code></pre></div><p>Here the player can move up, but we are only hitting one side of the box. We have to take into account that we need to move the other part along as well. Even more complicated, we can get into the following situation.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>######
</span></span><span style=display:flex><span>#[]  #
</span></span><span style=display:flex><span>#[][]#
</span></span><span style=display:flex><span># [] #
</span></span><span style=display:flex><span># @  #
</span></span><span style=display:flex><span>######
</span></span></code></pre></div><p>In this situation we can not move, even though the 2nd box on the middle layer might think we can, as it has a white-space above it.</p><p>I worked on arrays for a while, but eventually went for a more &ldquo;Java&rdquo; solution and create the factory as objects. Using the objects it is possible to attack the problem more in a &ldquo;game engine&rdquo; type of way, by making each object react to the interaction.</p><p>My code is horrible not-optimized, I apologize for that right away, but it gets the job done :D</p><p>Firstly, I split the process out into two segments, first to see if we can move, then to actually move. Side note: I should really use a lookup table for the coordinate to find the objects instead of looping over it.</p><p>The objects are simple POJOs, all extending the aptly named <code>Thing</code>.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f38ba8>class</span> <span style=color:#f9e2af>Player</span> <span style=color:#f38ba8>extends</span> Thing {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>public</span> <span style=color:#89b4fa>Player</span>(Coord start, Coord end) {
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>super</span>(start, end);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>class</span> <span style=color:#f9e2af>Wall</span> <span style=color:#f38ba8>extends</span> Thing {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>public</span> <span style=color:#89b4fa>Wall</span>(Coord start, Coord end) {
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>super</span>(start, end);
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>this</span>.<span style=color:#89b4fa>canMove</span> <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#fab387>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>class</span> <span style=color:#f9e2af>Box</span> <span style=color:#f38ba8>extends</span> Thing {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>public</span> <span style=color:#89b4fa>Box</span>(Coord start, Coord end) {
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>super</span>(start, end);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Thing</code> has all the logic, with <code>canMove()</code> and <code>move</code> basically doing the same thing, except for <code>move</code> actually moving the objects into a new coordinate. Only if we have a space as neighbor, or if <strong><strong>all</strong></strong> of the neighbors can move, only then do we move the current object.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f38ba8>boolean</span> <span style=color:#89b4fa>move</span>(List<span style=color:#89dceb;font-weight:700>&lt;</span>Thing<span style=color:#89dceb;font-weight:700>&gt;</span> factory, Coord direction) {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> (<span style=color:#89dceb;font-weight:700>!</span>canMove)
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>return</span> <span style=color:#fab387>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Coord nsp <span style=color:#89dceb;font-weight:700>=</span> start.<span style=color:#89b4fa>add</span>(direction);
</span></span><span style=display:flex><span>    Coord nep <span style=color:#89dceb;font-weight:700>=</span> end.<span style=color:#89b4fa>add</span>(direction);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Set<span style=color:#89dceb;font-weight:700>&lt;</span>Thing<span style=color:#89dceb;font-weight:700>&gt;</span> hits <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>new</span> HashSet<span style=color:#89dceb;font-weight:700>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>for</span> (<span style=color:#f38ba8>var</span> t : factory) {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> (t <span style=color:#89dceb;font-weight:700>==</span> <span style=color:#cba6f7>this</span>)
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>continue</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> (t.<span style=color:#89b4fa>collidesWith</span>(nsp))
</span></span><span style=display:flex><span>            hits.<span style=color:#89b4fa>add</span>(t);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> (t.<span style=color:#89b4fa>collidesWith</span>(nep))
</span></span><span style=display:flex><span>            hits.<span style=color:#89b4fa>add</span>(t);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> (hits.<span style=color:#89b4fa>size</span>() <span style=color:#89dceb;font-weight:700>==</span> 0) { <span style=color:#6c7086;font-style:italic>// space, so we can move ourself</span>
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>this</span>.<span style=color:#89b4fa>start</span> <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>this</span>.<span style=color:#89b4fa>start</span>.<span style=color:#89b4fa>add</span>(direction);
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>this</span>.<span style=color:#89b4fa>end</span> <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>this</span>.<span style=color:#89b4fa>end</span>.<span style=color:#89b4fa>add</span>(direction);
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>return</span> <span style=color:#fab387>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> (hits.<span style=color:#89b4fa>stream</span>().<span style=color:#89b4fa>allMatch</span>(t <span style=color:#89dceb;font-weight:700>-&gt;</span> t.<span style=color:#89b4fa>move</span>(factory, direction))) {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>this</span>.<span style=color:#89b4fa>start</span> <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>this</span>.<span style=color:#89b4fa>start</span>.<span style=color:#89b4fa>add</span>(direction);
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>this</span>.<span style=color:#89b4fa>end</span> <span style=color:#89dceb;font-weight:700>=</span> <span style=color:#cba6f7>this</span>.<span style=color:#89b4fa>end</span>.<span style=color:#89b4fa>add</span>(direction);
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>return</span> <span style=color:#fab387>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> <span style=color:#fab387>false</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Collision is checked against both the left and right hand side of the object. Meaning that we can easily handle boxes of size 2.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f38ba8>boolean</span> <span style=color:#89b4fa>collidesWith</span>(Coord c) {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> ((start.<span style=color:#89b4fa>x</span>() <span style=color:#89dceb;font-weight:700>==</span> c.<span style=color:#89b4fa>x</span>() <span style=color:#89dceb;font-weight:700>&amp;&amp;</span> start.<span style=color:#89b4fa>y</span>() <span style=color:#89dceb;font-weight:700>==</span> c.<span style=color:#89b4fa>y</span>()) <span style=color:#89dceb;font-weight:700>||</span> (end.<span style=color:#89b4fa>x</span>() <span style=color:#89dceb;font-weight:700>==</span> c.<span style=color:#89b4fa>x</span>() <span style=color:#89dceb;font-weight:700>&amp;&amp;</span> end.<span style=color:#89b4fa>y</span>() <span style=color:#89dceb;font-weight:700>==</span> c.<span style=color:#89b4fa>y</span>())) {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>return</span> <span style=color:#fab387>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> <span style=color:#fab387>false</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Much more work then I thought it would be, but a nice solution anyways.</p><h2 id=more-to-come>More to come<a hidden class=anchor aria-hidden=true href=#more-to-come>#</a></h2><p>[This article will be update with more days]</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://www.arjenwiersma.nl/posts/ifixit-dell/><span class=title>Next ¬ª</span><br><span>The right to repair</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Advent of Code 2024 on twitter" href="https://twitter.com/intent/tweet/?text=Advent%20of%20Code%202024&amp;url=https%3a%2f%2fwww.arjenwiersma.nl%2fposts%2faoc-2024%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share Advent of Code 2024 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwww.arjenwiersma.nl%2fposts%2faoc-2024%2f&amp;title=Advent%20of%20Code%202024&amp;summary=Advent%20of%20Code%202024&amp;source=https%3a%2f%2fwww.arjenwiersma.nl%2fposts%2faoc-2024%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share Advent of Code 2024 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.arjenwiersma.nl%2fposts%2faoc-2024%2f&title=Advent%20of%20Code%202024"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share Advent of Code 2024 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.arjenwiersma.nl%2fposts%2faoc-2024%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share Advent of Code 2024 on whatsapp" href="https://api.whatsapp.com/send?text=Advent%20of%20Code%202024%20-%20https%3a%2f%2fwww.arjenwiersma.nl%2fposts%2faoc-2024%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share Advent of Code 2024 on telegram" href="https://telegram.me/share/url?text=Advent%20of%20Code%202024&amp;url=https%3a%2f%2fwww.arjenwiersma.nl%2fposts%2faoc-2024%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.arjenwiersma.nl/>Arjen Wiersma</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>