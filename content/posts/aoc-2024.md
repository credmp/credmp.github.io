+++
title = "Advent of Code 2024"
author = ["Arjen Wiersma"]
date = 2024-12-02T22:59:00+01:00
categories = ["writing"]
draft = false
+++

It is December again and that means it is time for the [Advent of Code](https://adventofcode.com/). Due to my workload and family obligations I will probably not be able to get very far this year, but still I wanted to write a post about it.

This year I am using Java, together with my students. My goal is to write as modern as possible Java, which means using streams and new language constructs where possible.


## Day 1 {#day-1}

In day 1 we are parsing 2 lists of numbers, with the lists printed vertically. This means each line has 2 numbers, one for list one and the other for list two. To parse these data structures I used a very nice stream where I `map` each line onto a `String[]` using `split`.

To be sure that the input is valid, the `peek` method allows you to check if the result is what you intended, and otherwise an exception will terminate everything. From here I `map` the `String[]` into a `Pair` record which holds the 2 numbers. Streaming over the resulting `pairs` the left and right lists can be extracted quite easily.

I loved this approach, it is very straightforward and does not have a lot of control flow.

```java
@Override
public List<List<Integer>> parseInput(List<String> input) {
    var pairs = input.stream()
        .map(s -> s.split("\\s+"))
        .peek(parts -> {
                if (parts.length != 2)
                    throw new IllegalArgumentException("Invalid input format");
            })
        .map(parts -> new Pair<>(Integer.parseInt(parts[0]), Integer.parseInt(parts[1])))
        .collect(Collectors.toList());

    var left = pairs.stream()
        .map(Pair::left)
        .collect(Collectors.toList());

    var right = pairs.stream()
        .map(Pair::right)
        .collect(Collectors.toList());

    return List.of(left, right);
}
```

Solving the problem with these lists was quite easy. In part 2 there was a need for a frequency table of a list. I also found a very nice solution to that problem using the `groupingBy` method from `Collectors`.

```java
input.get(1).stream()
    .collect(Collectors.groupingBy(n -> n, Collectors.counting()));
```


## Day 2 {#day-2}

I really liked day 2, the first part was quite straightforward. You have to identify increment or decrement only lists and apply some conditions to them.

Part 2 was much more interesting, here you have to account for fault tolerance. In the Python implementations that were posted the common solution is to concatenate 2 parts of the array and then rerun the validation logic.

Using streams we can something very similar. First we use an `IntStream` to iterate over every `int[]` (report). Then for every `int` in that report, we construct a new array by `filtering` out the index of the current item. After that it is a simple case of determining increment or decrement and applying the conditional logic.

> Suppose you have a list of `[1,2,4,7]`, while iterating it will first hit index `0`, the `filter` will prevent that entry from continuing. Next `1` through `3` will continue and as a result of `toArray()` a new array will be constructed with only those items.

```text
x == 0
     |    map ------.
     v  -------     v
    [1, 2, 4, 7]    [2,4,7]
```

```java
input.stream()
    // Loop over the list
    .filter(in -> IntStream.range(0, in.length) // take a report
            // for every entry in that int[]
            .anyMatch(x -> {
                    // create a new list, excluding the one we are on now
                    int[] c = IntStream.range(0, in.length)
                        .filter(i -> i != x)
                        .map(i -> in[i])
                        .toArray();

                    boolean allInc = IntStream.range(0, c.length - 1)
                        .allMatch(i -> c[i] <= c[i + 1]);

                    boolean allDec = IntStream.range(0, c.length - 1)
                        .allMatch(i -> c[i] >= c[i + 1]);

                    boolean good = IntStream.range(0, c.length - 1)
                        .allMatch(i -> Math.abs(c[i] - c[i + 1]) >= 1 &&
                                  Math.abs(c[i] - c[i + 1]) <= 3);

                    // matching the condition
                    return (allInc || allDec) && good;
                })
            )
    .count();
```

My first solution was nothing like this, but after refining it I am very happy with how clean it came out.

[This article will be update with more days]
